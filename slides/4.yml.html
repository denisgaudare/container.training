<!DOCTYPE html>
<html>
  <head>
    <title>Kubernetes Avancé </title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="workshop.css">
  </head>
  <body>
    <!--
    <div style="position: absolute; left: 20%; right: 20%; top: 30%;">
      <h1 style="font-size: 3em;">Loading ...</h1>
      The slides should show up here. If they don't, it might be
      because you are accessing this file directly from your filesystem.
      It needs to be served from a web server. You can try this:
      <pre>
        docker-compose up -d
        open http://localhost:8888/workshop.html # on MacOS
        xdg-open http://localhost:8888/workshop.html # on Linux
      </pre>
      Once the slides are loaded, this notice disappears when you
      go full screen (e.g. by hitting "f").
    </div>
    -->
    <textarea id="source">class: title, self-paced

Kubernetes Avancé<br/>

.nav[*Self-paced version*]

.debug[
```
 M .gitignore
 M slides/1.yml.html
 M slides/2.yml
 M slides/2.yml.html
 M slides/3.yml.html
 M slides/4.yml.html

```

These slides have been built from commit: 3b9c256


[shared/title.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/title.md)]
---

class: title, in-person

Kubernetes Avancé<br/><br/></br>


<!--
WiFi: **Something**<br/>
Password: **Something**

**Be kind to the WiFi!**<br/>
*Use the 4G or 5G network.*
*Don't use your hotspot.*<br/>
*Don't stream videos or download big files during the workshop*<br/>
*Thank you!*
-->

.debug[[shared/title.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/title.md)]
---

## Exercises

- In a regular basis, there will be a series of exercises

- To make the most out of the training, please try the exercises!

  (it will help to practice and memorize the content of the day)

- We recommend to take sufficent time to work on the exercises

  (if you understood the content of the day, it will be much faster)

- Each day will start with a quick review of the content of the previous day

.debug[[logistics-template.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/logistics-template.md)]
---
## A brief introduction

- We are a collectif of professionals and instructors interested in leading workshops and tutorials
  
- Credit is to be shared among various fellow specialists, info found in books, articles on the Internet, and thanks to (long) hours of work.

- The slides are also to be used along, on your own, at your own pace

- Are included in these slides, as much information as possible

- It is recommend having a mentor to help you ...

- ... Or be comfortable spending some time reading the Kubernetes [documentation](https://kubernetes.io/docs/) ...

- ... And looking for answers on [StackOverflow](http://stackoverflow.com/questions/tagged/kubernetes) and other outlets

- ... and myself [Denis Gaudaré](mailto:denisgaudare@gmail.com)

.debug[[k8s/intro.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/intro.md)]
---

class: self-paced

## Hands on, you shall practice

- Nobody ever became a Jedi by spending their lives reading Wookiepedia

- Likewise, it will take more than merely *reading* these slides
  to make you an expert

- These slides include *tons* of demos, exercises, and examples

- They assume that you have access to a Kubernetes cluster

- If you are attending a workshop or tutorial:
  <br/>you will be given specific instructions to access your cluster

- If you are doing this on your own:
  <br/>the first chapter will give you various options to get your own cluster

.debug[[k8s/intro.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/intro.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-pre-requirements
class: title

 Pre-requirements

.nav[
[Previous part](#toc-)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-network-policies)
]

.debug[(automatically generated title slide)]

---
# Pre-requirements

- Be comfortable with the UNIX command line

  - navigating directories

  - editing files

  - a little bit of bash-fu (environment variables, loops)

- Some Docker knowledge

  - `docker run`, `docker ps`, `docker build`

  - ideally, you know how to write a Dockerfile and build it
    <br/>
    (even if it's a `FROM` line and a couple of `RUN` commands)

- It's totally OK if you are not a Docker expert!

.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---

class: title

*Tell me and I forget.*
<br/>
*Teach me and I remember.*
<br/>
*Involve me and I learn.*

Misattributed to Benjamin Franklin

[(Probably inspired by Chinese Confucian philosopher Xunzi)](https://www.barrypopik.com/index.php/new_york_city/entry/tell_me_and_i_forget_teach_me_and_i_may_remember_involve_me_and_i_will_lear/)

.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---

## Hands-on sections

- The whole workshop is hands-on

- We are going to build, ship, and run containers!

- You are invited to reproduce all the demos

- All hands-on sections are clearly identified, like the gray rectangle below

.lab[

- This is the stuff you're supposed to do!

- Go to github.com/denisgaudare/container.training/slides to view these slides

<!-- ```open github.com/denisgaudare/container.training/slides``` -->

]

.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---

class: in-person

## Where are we going to run our containers?

.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---

class: in-person, pic
## Everyone wins !!!

![Everyone wins](images/logo-entreprise.jpg)

.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---

class: in-person

## You get a cluster of cloud VMs

- Each person gets a private cluster of cloud VMs (not shared with anybody else)

- They'll remain up for the duration of the workshop

- You should have access to a machine (SSH+Key or User/Password)

- You can automatically SSH from one VM to another


.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---

class: in-person

## Why don't we run containers locally?

- Installing this stuff can be hard on some machines

  (32 bits CPU or OS... Laptops without administrator access... etc.)

- *"The whole team downloaded all these container images from the WiFi!
  <br/>... and it went great!"* (Literally no-one ever)

- All you need is a computer (or even a phone or tablet!), with:

  - an Internet connection

  - a web browser

  - an SSH client

.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---

class: in-person

## SSH clients

- On Linux, OS X, FreeBSD... you are probably all set

- On Windows, get one of these:

  - [putty](http://www.putty.org/)
  - Microsoft [Win32 OpenSSH](https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH)
  - [Git BASH](https://git-for-windows.github.io/)
  - [MobaXterm](http://mobaxterm.mobatek.net/)

- On Android, [JuiceSSH](https://juicessh.com/)
  ([Play Store](https://play.google.com/store/apps/details?id=com.sonelli.juicessh))
  works pretty well

- Nice-to-have: [Mosh](https://mosh.org/) instead of SSH, if your Internet connection tends to lose packets

.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---

class: in-person, extra-details

## What is this Mosh thing?

*You don't have to use Mosh or even know about it to follow along.
<br/>
We're just telling you about it because some of us think it's cool!*

- Mosh is "the mobile shell"

- It is essentially SSH over UDP, with roaming features

- It retransmits packets quickly, so it works great even on lossy connections

  (Like hotel or conference WiFi)

- It has intelligent local echo, so it works great even in high-latency connections

  (Like hotel or conference WiFi)

- It supports transparent roaming when your client IP address changes

  (Like when you hop from hotel to conference WiFi)

.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---

class: in-person, extra-details

## Using Mosh

- To install it: `(apt|yum|brew) install mosh`

- It has been pre-installed on the VMs that we are using

- To connect to a remote machine: `mosh user@host`

  (It is going to establish an SSH connection, then hand off to UDP)

- It requires UDP ports to be open

  (By default, it uses a UDP port between 60000 and 61000)

.debug[[shared/prereqs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/prereqs.md)]
---
## WebSSH

- The virtual machines are also accessible via WebSSH

- This can be useful if:

  - you can't install an SSH client on your machine

  - SSH connections are blocked (by firewall or local policy)

- To use WebSSH, connect to the IP address of the remote VM on port 1080

  (each machine runs a WebSSH server)

- Then provide the login and password indicated on your card

.debug[[shared/webssh.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/webssh.md)]
---

## Good to know

- WebSSH uses WebSocket

- If you're having connections issues, try to disable your HTTP proxy

  (many HTTP proxies can't handle WebSocket properly)

- Most keyboard shortcuts should work, except Ctrl-W

  (as it is hardwired by the browser to "close this tab")

.debug[[shared/webssh.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/webssh.md)]
---
class: in-person

## Connecting to our lab environment

.lab[

- Log into the first VM (`node1`) with your SSH client:
  ```bash
  ssh `user`@`A.B.C.D`
  ```

  (Replace `user` and `A.B.C.D` with the user and IP address provided to you)

<!--
```bash
for N in $(awk '/\Wnode/{print $2}' /etc/hosts); do
  ssh -o StrictHostKeyChecking=no $N true
done
```

```bash
### FIXME find a way to reset the cluster, maybe?
```
-->

]

You should see a prompt looking like this:
```
[A.B.C.D] (...) user@node1 ~
$
```
If anything goes wrong — ask for help!

.debug[[shared/connecting.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/connecting.md)]
---

class: in-person

## `tailhist`

- The shell history of the instructor is available online in real time

- Note the IP address of the instructor's virtual machine (A.B.C.D)

- Open http://A.B.C.D:1088 in your browser and you should see the history

- The history is updated in real time

  (using a WebSocket connection)

- It should be green when the WebSocket is connected

  (if it turns red, reloading the page should fix it)

.debug[[shared/connecting.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/connecting.md)]
---

## Doing or re-doing the workshop on your own?

- Use something like
  [Play-With-Docker](http://play-with-docker.com/) or
  [Play-With-Kubernetes](https://training.play-with-kubernetes.com/)

  Zero setup effort; but environment are short-lived and
  might have limited resources

- Create your own cluster (local or cloud VMs)

  Small setup effort; small cost; flexible environments

- Create a bunch of clusters for you and your friends
    ([instructions](https://github.com/denisgaudare/container.training/tree/master/prepare-vms))

  Bigger setup effort; ideal for group training

.debug[[shared/connecting.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/connecting.md)]
---

## For a consistent Kubernetes experience ...

- If you are using your own Kubernetes cluster, you can use [jpetazzo/shpod](https://github.com/denisgaudare/shpod)

- `shpod` provides a shell running in a pod on your own cluster

- It comes with many tools pre-installed (helm, stern...)

- These tools are used in many demos and exercises in these slides

- `shpod` also gives you completion and a fancy prompt

- It can also be used as an SSH server if needed

.debug[[shared/connecting.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/connecting.md)]
---

class: self-paced

## Get your own Docker nodes

- If you already have some Docker nodes: great!

- If not: let's get some thanks to Play-With-Docker

.lab[

- Go to http://www.play-with-docker.com/

- Log in

- Create your first node

<!-- ```open http://www.play-with-docker.com/``` -->

]

You will need a Docker ID to use Play-With-Docker.

(Creating a Docker ID is free.)

.debug[[shared/connecting.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/connecting.md)]
---

## We will (mostly) interact with node1 only

*These remarks apply only when using multiple nodes, of course.*

- Unless instructed, **all commands must be run from the first VM, `node1`**

- We will only check out/copy the code on `node1`

- During normal operations, we do not need access to the other nodes

- If we had to troubleshoot issues, we would use a combination of:

  - SSH (to access system logs, daemon status...)

  - Docker API (to check running containers and container engine status)

.debug[[shared/connecting.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/connecting.md)]
---

## Terminals

Once in a while, the instructions will say:
<br/>"Open a new terminal."

There are multiple ways to do this:

- create a new window or tab on your machine, and SSH into the VM;

- use screen or tmux on the VM and open a new window from there.

You are welcome to use the method that you feel the most comfortable with.

.debug[[shared/connecting.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/connecting.md)]
---

## Tmux cheat sheet

[Tmux](https://en.wikipedia.org/wiki/Tmux) is a terminal multiplexer like `screen`.

*You don't have to use it or even know about it to follow along.
<br/>
But some of us like to use it to switch between terminals.
<br/>
It has been preinstalled on your workshop nodes.*

- Ctrl-b c → creates a new window
- Ctrl-b n → go to next window
- Ctrl-b p → go to previous window
- Ctrl-b " → split window top/bottom
- Ctrl-b % → split window left/right
- Ctrl-b Alt-1 → rearrange windows in columns
- Ctrl-b Alt-2 → rearrange windows in rows
- Ctrl-b arrows → navigate to other windows
- Ctrl-b d → detach session
- tmux attach → re-attach to session

.debug[[shared/connecting.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/connecting.md)]
---

name: toc-part-1

## Part 1

- [Pre-requirements](#toc-pre-requirements)


.debug[(auto-generated TOC)]
---
name: toc-part-2

## Part 2

- [Network policies](#toc-network-policies)

- [Authentication and authorization](#toc-authentication-and-authorization)


.debug[(auto-generated TOC)]
---
name: toc-part-3

## Part 3

- [Extending the Kubernetes API](#toc-extending-the-kubernetes-api)

- [Operators](#toc-operators)

- [Sealed Secrets](#toc-sealed-secrets)

- [Custom Resource Definitions](#toc-custom-resource-definitions)

- [Exercise — sealed secrets](#toc-exercise--sealed-secrets)


.debug[(auto-generated TOC)]
---
name: toc-part-4

## Part 4

- [Resource Limits](#toc-resource-limits)

- [Defining min, max, and default resources](#toc-defining-min-max-and-default-resources)

- [Namespace quotas](#toc-namespace-quotas)

- [Limiting resources in practice](#toc-limiting-resources-in-practice)

- [Checking Node and Pod resource usage](#toc-checking-node-and-pod-resource-usage)

- [Cluster sizing](#toc-cluster-sizing)

- [The Horizontal Pod Autoscaler](#toc-the-horizontal-pod-autoscaler)


.debug[(auto-generated TOC)]
---
name: toc-part-5

## Part 5

- [The Aggregation Layer](#toc-the-aggregation-layer)

- [Collecting metrics with Prometheus](#toc-collecting-metrics-with-prometheus)

- [Scaling with custom metrics](#toc-scaling-with-custom-metrics)


.debug[(auto-generated TOC)]
---
name: toc-part-6

## Part 6

- [Dynamic Admission Control](#toc-dynamic-admission-control)

- [Policy Management with Kyverno](#toc-policy-management-with-kyverno)


.debug[(auto-generated TOC)]
---
name: toc-part-7

## Part 7

- [Stateful sets](#toc-stateful-sets)

- [Local Persistent Volumes](#toc-local-persistent-volumes)

- [An ElasticSearch Operator](#toc-an-elasticsearch-operator)

- [OpenEBS ](#toc-openebs-)


.debug[(auto-generated TOC)]



.debug[[shared/toc.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/shared/toc.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/ShippingContainerSFBay.jpg)]

---

name: toc-network-policies
class: title

 Network policies

.nav[
[Previous part](#toc-pre-requirements)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-authentication-and-authorization)
]

.debug[(automatically generated title slide)]

---
# Network policies

- Namespaces help us to *organize* resources

- Namespaces do not provide isolation

- By default, every pod can contact every other pod

- By default, every service accepts traffic from anyone

- If we want this to be different, we need *network policies*

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## What's a network policy?

A network policy is defined by the following things.

- A *pod selector* indicating which pods it applies to

  e.g.: "all pods in namespace `blue` with the label `zone=internal`"

- A list of *ingress rules* indicating which inbound traffic is allowed

  e.g.: "TCP connections to ports 8000 and 8080 coming from pods with label `zone=dmz`,
  and from the external subnet 4.42.6.0/24, except 4.42.6.5"

- A list of *egress rules* indicating which outbound traffic is allowed

A network policy can provide ingress rules, egress rules, or both.

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## How do network policies apply?

- A pod can be "selected" by any number of network policies

- If a pod isn't selected by any network policy, then its traffic is unrestricted

  (In other words: in the absence of network policies, all traffic is allowed)

- If a pod is selected by at least one network policy, then all traffic is blocked ...

  ... unless it is explicitly allowed by one of these network policies

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

class: extra-details

## Traffic filtering is flow-oriented

- Network policies deal with *connections*, not individual packets

- Example: to allow HTTP (80/tcp) connections to pod A, you only need an ingress rule

  (You do not need a matching egress rule to allow response traffic to go through)

- This also applies for UDP traffic

  (Allowing DNS traffic can be done with a single rule)

- Network policy implementations use stateful connection tracking

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Pod-to-pod traffic

- Connections from pod A to pod B have to be allowed by both pods:

  - pod A has to be unrestricted, or allow the connection as an *egress* rule

  - pod B has to be unrestricted, or allow the connection as an *ingress* rule

- As a consequence: if a network policy restricts traffic going from/to a pod,
  <br/>
  the restriction cannot be overridden by a network policy selecting another pod

- This prevents an entity managing network policies in namespace A
  (but without permission to do so in namespace B)
  from adding network policies giving them access to namespace B

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## The rationale for network policies

- In network security, it is generally considered better to "deny all, then allow selectively"

  (The other approach, "allow all, then block selectively" makes it too easy to leave holes)

- As soon as one network policy selects a pod, the pod enters this "deny all" logic

- Further network policies can open additional access

- Good network policies should be scoped as precisely as possible

- In particular: make sure that the selector is not too broad

  (Otherwise, you end up affecting pods that were otherwise well secured)

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Our first network policy

This is our game plan:

- run a web server in a pod

- create a network policy to block all access to the web server

- create another network policy to allow access only from specific pods

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Running our test web server

.lab[

- Let's use the `nginx` image:
  ```bash
  kubectl create deployment testweb --image=nginx
  ```

<!--
```bash
kubectl wait deployment testweb --for condition=available
```
-->

- Find out the IP address of the pod with one of these two commands:
  ```bash
  kubectl get pods -o wide -l app=testweb
  IP=$(kubectl get pods -l app=testweb -o json | jq -r .items[0].status.podIP)
  ```

- Check that we can connect to the server:
  ```bash
  curl $IP
  ```
]

The `curl` command should show us the "Welcome to nginx!" page.

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Adding a very restrictive network policy

- The policy will select pods with the label `app=testweb`

- It will specify an empty list of ingress rules (matching nothing)

.lab[

- Apply the policy in this YAML file:
  ```bash
    kubectl apply -f ~/container.training/k8s/netpol-deny-all-for-testweb.yaml
  ```

- Check if we can still access the server:
  ```bash
  curl $IP
  ```

<!--
```wait curl```
```key ^C```
-->

]

The `curl` command should now time out.

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Looking at the network policy

This is the file that we applied:

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: deny-all-for-testweb
spec:
  podSelector:
    matchLabels:
      app: testweb
  ingress: []


```

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Allowing connections only from specific pods

- We want to allow traffic from pods with the label `run=testcurl`

- Reminder: this label is automatically applied when we do `kubectl run testcurl ...`

.lab[

- Apply another policy:
  ```bash
  kubectl apply -f ~/container.training/k8s/netpol-allow-testcurl-for-testweb.yaml
  ```

]

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Looking at the network policy

This is the second file that we applied:

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-testcurl-for-testweb
spec:
  podSelector:
    matchLabels:
      app: testweb
  ingress:
  - from:
    - podSelector:
        matchLabels:
          run: testcurl


```

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Testing the network policy

- Let's create pods with, and without, the required label

.lab[

- Try to connect to testweb from a pod with the `run=testcurl` label:
  ```bash
  kubectl run testcurl --rm -i --image=centos -- curl -m3 $IP
  ```

- Try to connect to testweb with a different label:
  ```bash
  kubectl run testkurl --rm -i --image=centos -- curl -m3 $IP
  ```

]

The first command will work (and show the "Welcome to nginx!" page).

The second command will fail and time out after 3 seconds.

(The timeout is obtained with the `-m3` option.)

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## An important warning

- Some network plugins only have partial support for network policies

- For instance, Weave added support for egress rules [in version 2.4](https://github.com/weaveworks/weave/pull/3313) (released in July 2018)

- But only recently added support for ipBlock [in version 2.5](https://github.com/weaveworks/weave/pull/3367) (released in Nov 2018)

- Unsupported features might be silently ignored

  (Making you believe that you are secure, when you're not)

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Network policies, pods, and services

- Network policies apply to *pods*

- A *service* can select multiple pods

  (And load balance traffic across them)

- It is possible that we can connect to some pods, but not some others

  (Because of how network policies have been defined for these pods)

- In that case, connections to the service will randomly pass or fail

  (Depending on whether the connection was sent to a pod that we have access to or not)

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Network policies and namespaces

- A good strategy is to isolate a namespace, so that:

  - all the pods in the namespace can communicate together

  - other namespaces cannot access the pods

  - external access has to be enabled explicitly

- Let's see what this would look like for the DockerCoins app!

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Network policies for DockerCoins

- We are going to apply two policies

- The first policy will prevent traffic from other namespaces

- The second policy will allow traffic to the `webui` pods

- That's all we need for that app!

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Blocking traffic from other namespaces

This policy selects all pods in the current namespace.

It allows traffic only from pods in the current namespace.

(An empty `podSelector` means "all pods.")

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: deny-from-other-namespaces
spec:
  podSelector: {}
  ingress:
  - from:
    - podSelector: {}
```

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Allowing traffic to `webui` pods

This policy selects all pods with label `app=webui`.

It allows traffic from any source.

(An empty `from` field means "all sources.")

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-webui
spec:
  podSelector:
    matchLabels:
      app: webui
  ingress:
  - from: []
```

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Applying both network policies

- Both network policies are declared in the file [k8s/netpol-dockercoins.yaml](https://github.com/denisgaudare/container.training/tree/master/k8s/netpol-dockercoins.yaml)

.lab[

- Apply the network policies:
  ```bash
  kubectl apply -f ~/container.training/k8s/netpol-dockercoins.yaml
  ```

- Check that we can still access the web UI from outside
  <br/>
  (and that the app is still working correctly!)

- Check that we can't connect anymore to `rng` or `hasher` through their ClusterIP

]

Note: using `kubectl proxy` or `kubectl port-forward` allows us to connect
regardless of existing network policies. This allows us to debug and
troubleshoot easily, without having to poke holes in our firewall.

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Cleaning up our network policies

- The network policies that we have installed block all traffic to the default namespace

- We should remove them, otherwise further demos and exercises will fail!

.lab[

- Remove all network policies:
  ```bash
  kubectl delete networkpolicies --all
  ```

]

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Protecting the control plane

- Should we add network policies to block unauthorized access to the control plane?

  (etcd, API server, etc.)

--

- At first, it seems like a good idea ...

--

- But it *shouldn't* be necessary:

  - not all network plugins support network policies

  - the control plane is secured by other methods (mutual TLS, mostly)

  - the code running in our pods can reasonably expect to contact the API
    <br/>
    (and it can do so safely thanks to the API permission model)

- If we block access to the control plane, we might disrupt legitimate code

- ...Without necessarily improving security

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Tools and resources

- [Cilium Network Policy Editor](https://editor.cilium.io/)

- [Tufin Network Policy Viewer](https://orca.tufin.io/netpol/)

- Two resources by [Ahmet Alp Balkan](https://ahmet.im/):

  - a [very good talk about network policies](https://www.youtube.com/watch?list=PLj6h78yzYM2P-3-xqvmWaZbbI1sW-ulZb&v=3gGpMmYeEO8) at KubeCon North America 2017

  - a repository of [ready-to-use recipes](https://github.com/ahmetb/kubernetes-network-policy-recipes) for network policies

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Documentation

- As always, the [Kubernetes documentation](https://kubernetes.io/docs/concepts/services-networking/network-policies/) is a good starting point

- The API documentation has a lot of detail about the format of various objects: <!-- ##VERSION## -->

  - [NetworkPolicy](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#networkpolicy-v1-networking-k8s-io)

  - [NetworkPolicySpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#networkpolicyspec-v1-networking-k8s-io)

  - [NetworkPolicyIngressRule](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#networkpolicyingressrule-v1-networking-k8s-io)

  - etc.

???

:EN:- Isolating workloads with Network Policies
:FR:- Isolation réseau avec les *network policies*

.debug[[k8s/netpol.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/netpol.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/aerial-view-of-containers.jpg)]

---

name: toc-authentication-and-authorization
class: title

 Authentication and authorization

.nav[
[Previous part](#toc-network-policies)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-extending-the-kubernetes-api)
]

.debug[(automatically generated title slide)]

---
# Authentication and authorization

- In this section, we will:

  - define authentication and authorization

  - explain how they are implemented in Kubernetes

  - talk about tokens, certificates, service accounts, RBAC ...

- But first: why do we need all this?

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## The need for fine-grained security

- The Kubernetes API should only be available for identified users

  - we don't want "guest access" (except in very rare scenarios)

  - we don't want strangers to use our compute resources, delete our apps ...

  - our keys and passwords should not be exposed to the public

- Users will often have different access rights

  - cluster admin (similar to UNIX "root") can do everything

  - developer might access specific resources, or a specific namespace

  - supervision might have read only access to *most* resources

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Example: custom HTTP load balancer

- Let's imagine that we have a custom HTTP load balancer for multiple apps

- Each app has its own *Deployment* resource

- By default, the apps are "sleeping" and scaled to zero

- When a request comes in, the corresponding app gets woken up

- After some inactivity, the app is scaled down again

- This HTTP load balancer needs API access (to scale up/down)

- What if *a wild vulnerability appears*?

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Consequences of vulnerability

- If the HTTP load balancer has the same API access as we do:

  *full cluster compromise (easy data leak, cryptojacking...)*

- If the HTTP load balancer has `update` permissions on the Deployments:

  *defacement (easy), MITM / impersonation (medium to hard)*

- If the HTTP load balancer only has permission to `scale` the Deployments:

  *denial-of-service*

- All these outcomes are bad, but some are worse than others

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Definitions

- Authentication = verifying the identity of a person

  On a UNIX system, we can authenticate with login+password, SSH keys ...

- Authorization = listing what they are allowed to do

  On a UNIX system, this can include file permissions, sudoer entries ...

- Sometimes abbreviated as "authn" and "authz"

- In good modular systems, these things are decoupled

   (so we can e.g. change a password or SSH key without having to reset access rights)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authentication in Kubernetes

- When the API server receives a request, it tries to authenticate it

  (it examines headers, certificates... anything available)

- Many authentication methods are available and can be used simultaneously

  (we will see them on the next slide)

- It's the job of the authentication method to produce:

  - the user name
  - the user ID
  - a list of groups

- The API server doesn't interpret these; that'll be the job of *authorizers*

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authentication methods

- TLS client certificates

  (that's the default for clusters provisioned with `kubeadm`)

- Bearer tokens

  (a secret token in the HTTP headers of the request)

- [HTTP basic auth](https://en.wikipedia.org/wiki/Basic_access_authentication)

  (carrying user and password in an HTTP header; [deprecated since Kubernetes 1.19](https://github.com/kubernetes/kubernetes/pull/89069))

- Authentication proxy

  (sitting in front of the API and setting trusted headers)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Anonymous requests

- If any authentication method *rejects* a request, it's denied

  (`401 Unauthorized` HTTP code)

- If a request is neither rejected nor accepted by anyone, it's anonymous

  - the user name is `system:anonymous`

  - the list of groups is `[system:unauthenticated]`

- By default, the anonymous user can't do anything

  (that's what you get if you just `curl` the Kubernetes API)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authentication with TLS certificates

- Enabled in almost all Kubernetes deployments

- The user name is indicated by the `CN` in the client certificate

- The groups are indicated by the `O` fields in the client certificate

- From the point of view of the Kubernetes API, users do not exist

  (i.e. there is no resource with `kind: User`)

- The Kubernetes API can be set up to use your custom CA to validate client certs

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Authentication for kubelet

- In most clusters, kubelets authenticate using certificates

  (`O=system:nodes`, `CN=system:node:name-of-the-node`)

- The Kubernetse API can act as a CA

  (by wrapping an X509 CSR into a CertificateSigningRequest resource)

- This enables kubelets to renew their own certificates

- It can also be used to issue user certificates

  (but it lacks flexibility; e.g. validity can't be customized)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## User certificates in practice

- The Kubernetes API server does not support certificate revocation

  (see issue [#18982](https://github.com/kubernetes/kubernetes/issues/18982))

- As a result, we don't have an easy way to terminate someone's access

  (if their key is compromised, or they leave the organization)

- Issue short-lived certificates if you use them to authenticate users!

  (short-lived = a few hours)

- This can be facilitated by e.g. Vault, cert-manager...

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## What if a certificate is compromised?

- Option 1: wait for the certificate to expire

  (which is why short-lived certs are convenient!)

- Option 2: remove access from that certificate's user and groups

  - if that user was `bob.smith`, create a new user `bob.smith.2`

  - if Bob was in groups `dev`, create a new group `dev.2`

  - let's agree that this is not a great solution!

- Option 3: re-create a new CA and re-issue all certificates

  - let's agree that this is an even worse solution!

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authentication with tokens

- Tokens are passed as HTTP headers:

  `Authorization: Bearer and-then-here-comes-the-token`

- Tokens can be validated through a number of different methods:

  - static tokens hard-coded in a file on the API server

  - [bootstrap tokens](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/) (special case to create a cluster or join nodes)

  - [OpenID Connect tokens](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens) (to delegate authentication to compatible OAuth2 providers)

  - service accounts (these deserve more details, coming right up!)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Service accounts

- A service account is a user that exists in the Kubernetes API

  (it is visible with e.g. `kubectl get serviceaccounts`)

- Service accounts can therefore be created / updated dynamically

  (they don't require hand-editing a file and restarting the API server)

- A service account is associated with a set of secrets

  (the kind that you can view with `kubectl get secrets`)

- Service accounts are generally used to grant permissions to applications, services...

  (as opposed to humans)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Checking our authentication method

- Let's check our kubeconfig file

- Do we have a certificate, a token, or something else?

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Inspecting a certificate

If we have a certificate, let's use the following command:

```bash
kubectl config view \
        --raw \
        -o json \
        | jq -r .users[0].user[\"client-certificate-data\"] \
        | openssl base64 -d -A \
        | openssl x509 -text \
        | grep Subject:
```

This command will show the `CN` and `O` fields for our certificate.

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Breaking down the command

- `kubectl config view` shows the Kubernetes user configuration
- `--raw` includes certificate information (which shows as REDACTED otherwise)
- `-o json` outputs the information in JSON format
- `| jq ...` extracts the field with the user certificate (in base64)
- `| openssl base64 -d -A` decodes the base64 format (now we have a PEM file)
- `| openssl x509 -text` parses the certificate and outputs it as plain text
- `| grep Subject:` shows us the line that interests us

→ We are user `kubernetes-admin`, in group `system:masters`.

(We will see later how and why this gives us the permissions that we have.)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Inspecting a token

If we have a token, let's use the following command:

```bash
kubectl config view \
        --raw \
        -o json \
        | jq -r .users[0].user.token \
        | base64 -d \
        | cut -d. -f2 \
        | base64 -d \
        | jq .
```

If our token is a JWT / OIDC token, this command will show its content.

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Other authentication methods

- Other types of tokens

  - these tokens are typically shorter than JWT or OIDC tokens

  - it is generally not possible to extract information from them

- Plugins

  - some clusters use external `exec` plugins

  - these plugins typically use API keys to generate or obtain tokens

  - example: the AWS EKS authenticator works this way

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Token authentication in practice

- We are going to list existing service accounts

- Then we will extract the token for a given service account

- And we will use that token to authenticate with the API

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Listing service accounts

.lab[

- The resource name is `serviceaccount` or `sa` for short:
  ```bash
  kubectl get sa
  ```

]

There should be just one service account in the default namespace: `default`.

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Finding the secret

.lab[

- List the secrets for the `default` service account:
  ```bash
  kubectl get sa default -o yaml
  SECRET=$(kubectl get sa default -o json | jq -r .secrets[0].name)
  ```

]

It should be named `default-token-XXXXX`.

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Extracting the token

- The token is stored in the secret, wrapped with base64 encoding

.lab[

- View the secret:
  ```bash
  kubectl get secret $SECRET -o yaml
  ```

- Extract the token and decode it:
  ```bash
  TOKEN=$(kubectl get secret $SECRET -o json \
          | jq -r .data.token | openssl base64 -d -A)
  ```

]

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Using the token

- Let's send a request to the API, without and with the token

.lab[

- Find the ClusterIP for the `kubernetes` service:
  ```bash
  kubectl get svc kubernetes
  API=$(kubectl get svc kubernetes -o json | jq -r .spec.clusterIP)
  ```

- Connect without the token:
  ```bash
  curl -k https://$API
  ```

- Connect with the token:
  ```bash
  curl -k -H "Authorization: Bearer $TOKEN" https://$API
  ```

]

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Results

- In both cases, we will get a "Forbidden" error

- Without authentication, the user is `system:anonymous`

- With authentication, it is shown as `system:serviceaccount:default:default`

- The API "sees" us as a different user

- But neither user has any rights, so we can't do nothin'

- Let's change that!

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authorization in Kubernetes

- There are multiple ways to grant permissions in Kubernetes, called [authorizers](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#authorization-modules):

  - [Node Authorization](https://kubernetes.io/docs/reference/access-authn-authz/node/) (used internally by kubelet; we can ignore it)

  - [Attribute-based access control](https://kubernetes.io/docs/reference/access-authn-authz/abac/) (powerful but complex and static; ignore it too)

  - [Webhook](https://kubernetes.io/docs/reference/access-authn-authz/webhook/) (each API request is submitted to an external service for approval)

  - [Role-based access control](https://kubernetes.io/docs/reference/access-authn-authz/rbac/) (associates permissions to users dynamically)

- The one we want is the last one, generally abbreviated as RBAC

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Role-based access control

- RBAC allows to specify fine-grained permissions

- Permissions are expressed as *rules*

- A rule is a combination of:

  - [verbs](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb) like create, get, list, update, delete...

  - resources (as in "API resource," like pods, nodes, services...)

  - resource names (to specify e.g. one specific pod instead of all pods)

  - in some case, [subresources](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources) (e.g. logs are subresources of pods)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Listing all possible verbs

- The Kubernetes API is self-documented

- We can ask it which resources, subresources, and verb exist

- One way to do this is to use:

  - `kubectl get --raw /api/v1` (for core resources with `apiVersion: v1`)

  - `kubectl get --raw /apis/<group>/<version>` (for other resources)

- The JSON response can be formatted with e.g. `jq` for readability

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Examples

- List all verbs across all `v1` resources

  ```bash
  kubectl get --raw /api/v1 | jq -r .resources[].verbs[] | sort -u
  ```

- List all resources and subresources in `apps/v1`

  ```bash
  kubectl get --raw /apis/apps/v1 | jq -r .resources[].name
  ```

- List which verbs are available on which resources in `networking.k8s.io`

  ```bash
  kubectl get --raw /apis/networking.k8s.io/v1 | \
          jq -r '.resources[] | .name + ": " + (.verbs | join(", "))'
  ```

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## From rules to roles to rolebindings

- A *role* is an API object containing a list of *rules*

  Example: role "external-load-balancer-configurator" can:
  - [list, get] resources [endpoints, services, pods]
  - [update] resources [services]

- A *rolebinding* associates a role with a user

  Example: rolebinding "external-load-balancer-configurator":
  - associates user "external-load-balancer-configurator"
  - with role "external-load-balancer-configurator"

- Yes, there can be users, roles, and rolebindings with the same name

- It's a good idea for 1-1-1 bindings; not so much for 1-N ones

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Cluster-scope permissions

- API resources Role and RoleBinding are for objects within a namespace

- We can also define API resources ClusterRole and ClusterRoleBinding

- These are a superset, allowing us to:

  - specify actions on cluster-wide objects (like nodes)

  - operate across all namespaces

- We can create Role and RoleBinding resources within a namespace

- ClusterRole and ClusterRoleBinding resources are global

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Pods and service accounts

- A pod can be associated with a service account

  - by default, it is associated with the `default` service account

  - as we saw earlier, this service account has no permissions anyway

- The associated token is exposed to the pod's filesystem

  (in `/var/run/secrets/kubernetes.io/serviceaccount/token`)

- Standard Kubernetes tooling (like `kubectl`) will look for it there

- So Kubernetes tools running in a pod will automatically use the service account

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## In practice

- We are going to run a pod

- This pod will use the default service account of its namespace

- We will check our API permissions

  (there shouldn't be any)

- Then we will bind a role to the service account

- We will check that we were granted the corresponding permissions

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Running a pod

- We'll use [Nixery](https://nixery.dev/) to run a pod with `curl` and `kubectl`

- Nixery automatically generates images with the requested packages

.lab[

- Run our pod:
  ```bash
  kubectl run eyepod --rm -ti --restart=Never \
          --image nixery.dev/shell/curl/kubectl -- bash
  ```

]

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Checking our permissions

- Normally, at this point, we don't have any API permission

.lab[

- Check our permissions with `kubectl`:
  ```bash
  kubectl get pods
  ```

]

- We should get a message telling us that our service account
  doesn't have permissions to list "pods" in the current namespace

- We can also make requests to the API server directly

  (use `kubectl -v6` to see the exact request URI!)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Binding a role to the service account

- Binding a role = creating a *rolebinding* object

- We will call that object `can-view`

  (but again, we could call it `view` or whatever we like)

.lab[

- Create the new role binding:
  ```bash
  kubectl create rolebinding can-view \
          --clusterrole=view \
          --serviceaccount=default:default
  ```

]

It's important to note a couple of details in these flags...

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Roles vs Cluster Roles

- We used `--clusterrole=view`

- What would have happened if we had used `--role=view`?

  - we would have bound the role `view` from the local namespace
    <br/>(instead of the cluster role `view`)

  - the command would have worked fine (no error)

  - but later, our API requests would have been denied

- This is a deliberate design decision

  (we can reference roles that don't exist, and create/update them later)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Users vs Service Accounts

- We used `--serviceaccount=default:default`

- What would have happened if we had used `--user=default:default`?

  - we would have bound the role to a user instead of a service account

  - again, the command would have worked fine (no error)

  - ...but our API requests would have been denied later

- What's about the `default:` prefix?

  - that's the namespace of the service account

  - yes, it could be inferred from context, but... `kubectl` requires it

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Checking our new permissions

- We should be able to *view* things, but not to *edit* them

.lab[

- Check our permissions with `kubectl`:
  ```bash
  kubectl get pods
  ```

- Try to create something:
  ```bash
  kubectl create deployment can-i-do-this --image=nginx
  ```

- Exit the container with `exit` or `^D`

<!-- ```key ^D``` -->

]

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## `kubectl run --serviceaccount`

- `kubectl run` also has a `--serviceaccount` flag

- ...But it's supposed to be deprecated "soon"

  (see [kubernetes/kubernetes#99732](https://github.com/kubernetes/kubernetes/pull/99732) for details)

- It's possible to specify the service account with an override:
  ```bash
  kubectl run my-pod -ti --image=alpine --restart=Never \
          --overrides='{ "spec": { "serviceAccountName" : "my-service-account" } }'
  ```

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `kubectl auth` and other CLI tools

- The `kubectl auth can-i` command can tell us:

  - if we can perform an action

  - if someone else can perform an action

  - what actions we can perform

- There are also other very useful tools to work with RBAC

- Let's do a quick review!

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `kubectl auth can-i dothis onthat`

- These commands will give us a `yes`/`no` answer:

  ```bash
  kubectl auth can-i list nodes
  kubectl auth can-i create pods
  kubectl auth can-i get pod/name-of-pod
  kubectl auth can-i get /url-fragment-of-api-request/
  kubectl auth can-i '*' services
  kubectl auth can-i get coffee
  kubectl auth can-i drink coffee
  ```

- The RBAC system is flexible

- We can check permissions on resources that don't exist yet (e.g. CRDs)

- We can check permissions for arbitrary actions

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `kubectl auth can-i ... --as someoneelse`

- We can check permissions on behalf of other users

  ```bash
  kubectl auth can-i list nodes \
          --as some-user
  kubectl auth can-i list nodes \
          --as system:serviceaccount:<namespace>:<name-of-service-account>
  ```

- We can also use `--as-group` to check permissions for members of a group

- `--as` and `--as-group` leverage the *impersonation API*

- These flags can be used with many other `kubectl` commands

  (not just `auth can-i`)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `kubectl auth can-i --list`

- We can list the actions that are available to us:

  ```bash
  kubectl auth can-i --list
  ```

- ... Or to someone else (with `--as SomeOtherUser`)

- This is very useful to check users or service accounts for overly broad permissions

  (or when looking for ways to exploit a security vulnerability!)

- To learn more about Kubernetes attacks and threat models around RBAC:

  📽️ [Hacking into Kubernetes Security for Beginners](https://www.youtube.com/watch?v=mLsCm9GVIQg)
  by [Ellen Körbes](https://twitter.com/ellenkorbes)
  and [Tabitha Sable](https://twitter.com/TabbySable)

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Other useful tools

- For auditing purposes, sometimes we want to know who can perform which actions

- There are a few tools to help us with that, available as `kubectl` plugins:

  - `kubectl who-can` / [kubectl-who-can](https://github.com/aquasecurity/kubectl-who-can) by Aqua Security

  - `kubectl access-matrix` / [Rakkess (Review Access)](https://github.com/corneliusweig/rakkess) by Cornelius Weig

  - `kubectl rbac-lookup` / [RBAC Lookup](https://github.com/FairwindsOps/rbac-lookup) by FairwindsOps

  - `kubectl rbac-tool` / [RBAC Tool](https://github.com/alcideio/rbac-tool) by insightCloudSec

- `kubectl` plugins can be installed and managed with `krew`

- They can also be installed and executed as standalone programs

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Where does this `view` role come from?

- Kubernetes defines a number of ClusterRoles intended to be bound to users

- `cluster-admin` can do *everything* (think `root` on UNIX)

- `admin` can do *almost everything* (except e.g. changing resource quotas and limits)

- `edit` is similar to `admin`, but cannot view or edit permissions

- `view` has read-only access to most resources, except permissions and secrets

*In many situations, these roles will be all you need.*

*You can also customize them!*

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Customizing the default roles

- If you need to *add* permissions to these default roles (or others),
  <br/>
  you can do it through the [ClusterRole Aggregation](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#aggregated-clusterroles) mechanism

- This happens by creating a ClusterRole with the following labels:
  ```yaml
    metadata:
      labels:
        rbac.authorization.k8s.io/aggregate-to-admin: "true"
        rbac.authorization.k8s.io/aggregate-to-edit: "true"
        rbac.authorization.k8s.io/aggregate-to-view: "true"
  ```

- This ClusterRole permissions will be added to `admin`/`edit`/`view` respectively

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## When should we use aggregation?

- By default, CRDs aren't included in `view` / `edit` / etc.

  (Kubernetes cannot guess which one are security sensitive and which ones are not)

- If we edit `view` / `edit` / etc directly, our edits will conflict

  (imagine if we have two CRDs and they both provide a custom `view` ClusterRole)

- Using aggregated roles lets us enrich the default roles without touching them

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## How aggregation works

- The corresponding roles will have `aggregationRules` like this:

   ```yaml
    aggregationRule:
      clusterRoleSelectors:
      - matchLabels:
          rbac.authorization.k8s.io/aggregate-to-view: "true"
   ```

- We can define our own custom roles with their own aggregation rules

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Where do our permissions come from?

- When interacting with the Kubernetes API, we are using a client certificate

- We saw previously that this client certificate contained:

  `CN=kubernetes-admin` and `O=system:masters`

- Let's look for these in existing ClusterRoleBindings:
  ```bash
  kubectl get clusterrolebindings -o yaml |
    grep -e kubernetes-admin -e system:masters
  ```

  (`system:masters` should show up, but not `kubernetes-admin`.)

- Where does this match come from?

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## The `system:masters` group

- If we eyeball the output of `kubectl get clusterrolebindings -o yaml`, we'll find out!

- It is in the `cluster-admin` binding:
  ```bash
  kubectl describe clusterrolebinding cluster-admin
  ```

- This binding associates `system:masters` with the cluster role `cluster-admin`

- And the `cluster-admin` is, basically, `root`:
  ```bash
  kubectl describe clusterrole cluster-admin
  ```

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `list` vs. `get`

⚠️ `list` grants read permissions to resources!

- It's not possible to give permission to list resources without also reading them

- This has implications for e.g. Secrets

  (if a controller needs to be able to enumerate Secrets, it will be able to read them)

???

:EN:- Authentication and authorization in Kubernetes
:EN:- Authentication with tokens and certificates
:EN:- Authorization with RBAC (Role-Based Access Control)
:EN:- Restricting permissions with Service Accounts
:EN:- Working with Roles, Cluster Roles, Role Bindings, etc.

:FR:- Identification et droits d'accès dans Kubernetes
:FR:- Mécanismes d'identification par jetons et certificats
:FR:- Le modèle RBAC *(Role-Based Access Control)*
:FR:- Restreindre les permissions grâce aux *Service Accounts*
:FR:- Comprendre les *Roles*, *Cluster Roles*, *Role Bindings*, etc.

.debug[[k8s/authn-authz.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/blue-containers.jpg)]

---

name: toc-extending-the-kubernetes-api
class: title

 Extending the Kubernetes API

.nav[
[Previous part](#toc-authentication-and-authorization)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-operators)
]

.debug[(automatically generated title slide)]

---
# Extending the Kubernetes API

There are multiple ways to extend the Kubernetes API.

We are going to cover:

- Controllers

- Dynamic Admission Webhooks

- Custom Resource Definitions (CRDs)

- The Aggregation Layer

But first, let's re(re)visit the API server ...

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Revisiting the API server

- The Kubernetes API server is a central point of the control plane

- Everything connects to the API server:

  - users (that's us, but also automation like CI/CD)

  - kubelets

  - network components (e.g. `kube-proxy`, pod network, NPC)

  - controllers; lots of controllers

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Some controllers

- `kube-controller-manager` runs built-on controllers

  (watching Deployments, Nodes, ReplicaSets, and much more)

- `kube-scheduler` runs the scheduler

  (it's conceptually not different from another controller)

- `cloud-controller-manager` takes care of "cloud stuff"

  (e.g. provisioning load balancers, persistent volumes...)

- Some components mentioned above are also controllers

  (e.g. Network Policy Controller)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## More controllers

- Cloud resources can also be managed by additional controllers

  (e.g. the [AWS Load Balancer Controller](https://github.com/kubernetes-sigs/aws-load-balancer-controller))

- Leveraging Ingress resources requires an Ingress Controller

  (many options available here; we can even install multiple ones!)

- Many add-ons (including CRDs and operators) have controllers as well

🤔 *What's even a controller ?!?*

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## What's a controller?

According to the [documentation](https://kubernetes.io/docs/concepts/architecture/controller/):

*Controllers are **control loops** that<br/>
**watch** the state of your cluster,<br/>
then make or request changes where needed.*

*Each controller tries to move the current cluster state closer to the desired state.*

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## What controllers do

- Watch resources

- Make changes:

  - purely at the API level (e.g. Deployment, ReplicaSet controllers)

  - and/or configure resources (e.g. `kube-proxy`)

  - and/or provision resources (e.g. load balancer controller)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Extending Kubernetes with controllers

- Random example:

  - watch resources like Deployments, Services ...

  - read annotations to configure monitoring

- Technically, this is not extending the API

  (but it can still be very useful!)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Other ways to extend Kubernetes

- Prevent or alter API requests before resources are committed to storage:

  *Admission Control*

- Create new resource types leveraging Kubernetes storage facilities:

  *Custom Resource Definitions*

- Create new resource types with different storage or different semantics:

  *Aggregation Layer*

- Spoiler alert: often, we will combine multiple techniques

  (and involve controllers as well!)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Admission controllers

- Admission controllers can vet or transform API requests

- The diagram on the next slide shows the path of an API request

  (courtesy of Banzai Cloud)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

class: pic

![API request lifecycle](images/api-request-lifecycle.png)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Types of admission controllers

- *Validating* admission controllers can accept/reject the API call

- *Mutating* admission controllers can modify the API request payload

- Both types can also trigger additional actions

  (e.g. automatically create a Namespace if it doesn't exist)

- There are a number of built-in admission controllers

  (see [documentation](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do) for a list)

- We can also dynamically define and register our own

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

class: extra-details

## Some built-in admission controllers

- ServiceAccount:

  automatically adds a ServiceAccount to Pods that don't explicitly specify one

- LimitRanger:

  applies resource constraints specified by LimitRange objects when Pods are created

- NamespaceAutoProvision:

  automatically creates namespaces when an object is created in a non-existent namespace

*Note: #1 and #2 are enabled by default; #3 is not.*

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Dynamic Admission Control

- We can set up *admission webhooks* to extend the behavior of the API server

- The API server will submit incoming API requests to these webhooks

- These webhooks can be *validating* or *mutating*

- Webhooks can be set up dynamically (without restarting the API server)

- To setup a dynamic admission webhook, we create a special resource:

  a `ValidatingWebhookConfiguration` or a `MutatingWebhookConfiguration`

- These resources are created and managed like other resources

  (i.e. `kubectl create`, `kubectl get`...)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Webhook Configuration

- A ValidatingWebhookConfiguration or MutatingWebhookConfiguration contains:

  - the address of the webhook

  - the authentication information to use with the webhook

  - a list of rules

- The rules indicate for which objects and actions the webhook is triggered

  (to avoid e.g. triggering webhooks when setting up webhooks)

- The webhook server can be hosted in or out of the cluster

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Dynamic Admission Examples

- Policy control

  ([Kyverno](https://kyverno.io/),
  [Open Policy Agent](https://www.openpolicyagent.org/docs/latest/))

- Sidecar injection

  (Used by some service meshes)

- Type validation

  (More on this later, in the CRD section)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Kubernetes API types

- Almost everything in Kubernetes is materialized by a resource

- Resources have a type (or "kind")

  (similar to strongly typed languages)

- We can see existing types with `kubectl api-resources`

- We can list resources of a given type with `kubectl get <type>`

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Creating new types

- We can create new types with Custom Resource Definitions (CRDs)

- CRDs are created dynamically

  (without recompiling or restarting the API server)

- CRDs themselves are resources:

  - we can create a new type with `kubectl create` and some YAML

  - we can see all our custom types with `kubectl get crds`

- After we create a CRD, the new type works just like built-in types

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Examples

- Representing composite resources

  (e.g. clusters like databases, messages queues ...)

- Representing external resources

  (e.g. virtual machines, object store buckets, domain names ...)

- Representing configuration for controllers and operators

  (e.g. custom Ingress resources, certificate issuers, backups ...)

- Alternate representations of other objects; services and service instances

  (e.g. encrypted secret, git endpoints ...)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## The aggregation layer

- We can delegate entire parts of the Kubernetes API to external servers

- This is done by creating APIService resources

  (check them with `kubectl get apiservices`!)

- The APIService resource maps a type (kind) and version to an external service

- All requests concerning that type are sent (proxied) to the external service

- This allows to have resources like CRDs, but that aren't stored in etcd

- Example: `metrics-server`

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Why?

- Using a CRD for live metrics would be extremely inefficient

  (etcd **is not** a metrics store; write performance is way too slow)

- Instead, `metrics-server`:

  - collects metrics from kubelets

  - stores them in memory

  - exposes them as PodMetrics and NodeMetrics (in API group metrics.k8s.io)

  - is registered as an APIService

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Drawbacks

- Requires a server

- ... that implements a non-trivial API (aka the Kubernetes API semantics)

- If we need REST semantics, CRDs are probably way simpler

- *Sometimes* synchronizing external state with CRDs might do the trick

  (unless we want the external state to be our single source of truth)

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Service catalog

- *Service catalog* is another extension mechanism

- It's not extending the Kubernetes API strictly speaking

  (but it still provides new features!)

- It doesn't create new types; it uses:

  - ClusterServiceBroker
  - ClusterServiceClass
  - ClusterServicePlan
  - ServiceInstance
  - ServiceBinding

- It uses the Open service broker API

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Documentation

- [Custom Resource Definitions: when to use them](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)

- [Custom Resources Definitions: how to use them](https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/)

- [Service Catalog](https://kubernetes.io/docs/concepts/extend-kubernetes/service-catalog/)

- [Built-in Admission Controllers](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/)

- [Dynamic Admission Controllers](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/)

- [Aggregation Layer](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)

???

:EN:- Overview of Kubernetes API extensions
:FR:- Comment étendre l'API Kubernetes

.debug[[k8s/extending-api.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/chinook-helicopter-container.jpg)]

---

name: toc-operators
class: title

 Operators

.nav[
[Previous part](#toc-extending-the-kubernetes-api)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-sealed-secrets)
]

.debug[(automatically generated title slide)]

---
# Operators

*An operator represents **human operational knowledge in software,**
<br/>
to reliably manage an application.
— [CoreOS](https://coreos.com/blog/introducing-operators.html)*

Examples:

- Deploying and configuring replication with MySQL, PostgreSQL ...

- Setting up Elasticsearch, Kafka, RabbitMQ, Zookeeper ...

- Reacting to failures when intervention is needed

- Scaling up and down these systems

.debug[[k8s/operators.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/operators.md)]
---

## What are they made from?

- Operators combine two things:

  - Custom Resource Definitions

  - controller code watching the corresponding resources and acting upon them

- A given operator can define one or multiple CRDs

- The controller code (control loop) typically runs within the cluster

  (running as a Deployment with 1 replica is a common scenario)

- But it could also run elsewhere

  (nothing mandates that the code run on the cluster, as long as it has API access)

.debug[[k8s/operators.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/operators.md)]
---

## Why use operators?

- Kubernetes gives us Deployments, StatefulSets, Services ...

- These mechanisms give us building blocks to deploy applications

- They work great for services that are made of *N* identical containers

  (like stateless ones)

- They also work great for some stateful applications like Consul, etcd ...

  (with the help of highly persistent volumes)

- They're not enough for complex services:

  - where different containers have different roles

  - where extra steps have to be taken when scaling or replacing containers

.debug[[k8s/operators.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/operators.md)]
---

## Use-cases for operators

- Systems with primary/secondary replication

  Examples: MariaDB, MySQL, PostgreSQL, Redis ...

- Systems where different groups of nodes have different roles

  Examples: ElasticSearch, MongoDB ...

- Systems with complex dependencies (that are themselves managed with operators)

  Examples: Flink or Kafka, which both depend on Zookeeper

.debug[[k8s/operators.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/operators.md)]
---

## More use-cases

- Representing and managing external resources

  (Example: [AWS S3 Operator](https://operatorhub.io/operator/awss3-operator-registry))

- Managing complex cluster add-ons

  (Example: [Istio operator](https://operatorhub.io/operator/istio))

- Deploying and managing our applications' lifecycles

  (more on that later)

.debug[[k8s/operators.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/operators.md)]
---

## How operators work

- An operator creates one or more CRDs

  (i.e., it creates new "Kinds" of resources on our cluster)

- The operator also runs a *controller* that will watch its resources

- Each time we create/update/delete a resource, the controller is notified

  (we could write our own cheap controller with `kubectl get --watch`)

.debug[[k8s/operators.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/operators.md)]
---

## Deploying our apps with operators

- It is very simple to deploy with `kubectl create deployment` / `kubectl expose`

- We can unlock more features by writing YAML and using `kubectl apply`

- Kustomize or Helm let us deploy in multiple environments

  (and adjust/tweak parameters in each environment)

- We can also use an operator to deploy our application

.debug[[k8s/operators.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/operators.md)]
---

## Pros and cons of deploying with operators

- The app definition and configuration is persisted in the Kubernetes API

- Multiple instances of the app can be manipulated with `kubectl get`

- We can add labels, annotations to the app instances

- Our controller can execute custom code for any lifecycle event

- However, we need to write this controller

- We need to be careful about changes

  (what happens when the resource `spec` is updated?)

.debug[[k8s/operators.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/operators.md)]
---

## Operators are not magic

- Look at this ElasticSearch resource definition:

  [k8s/eck-elasticsearch.yaml](https://github.com/denisgaudare/container.training/tree/master/k8s/eck-elasticsearch.yaml)

- What should happen if we flip the TLS flag? Twice?

- What should happen if we add another group of nodes?

- What if we want different images or parameters for the different nodes?

*Operators can be very powerful.
<br/>
But we need to know exactly the scenarios that they can handle.*

???

:EN:- Kubernetes operators
:FR:- Les opérateurs

.debug[[k8s/operators.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/operators.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/container-cranes.jpg)]

---

name: toc-sealed-secrets
class: title

 Sealed Secrets

.nav[
[Previous part](#toc-operators)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-custom-resource-definitions)
]

.debug[(automatically generated title slide)]

---
# Sealed Secrets

- Kubernetes provides the "Secret" resource to store credentials, keys, passwords ...

- Secrets can be protected with RBAC

  (e.g. "you can write secrets, but only the app's service account can read them")

- [Sealed Secrets](https://github.com/bitnami-labs/sealed-secrets) is an operator that lets us store secrets in code repositories

- It uses asymetric cryptography:

  - anyone can *encrypt* a secret

  - only the cluster can *decrypt* a secret

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Principle

- The Sealed Secrets operator uses a *public* and a *private* key

- The public key is available publicly (duh!)

- We use the public key to encrypt secrets into a SealedSecret resource

- the SealedSecret resource can be stored in a code repo (even a public one)

- The SealedSecret resource is `kubectl apply`'d to the cluster

- The Sealed Secrets controller decrypts the SealedSecret with the private key

  (this creates a classic Secret resource)

- Nobody else can decrypt secrets, since only the controller has the private key

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## In action

- We will install the Sealed Secrets operator

- We will generate a Secret

- We will "seal" that Secret (generate a SealedSecret)

- We will load that SealedSecret on the cluster

- We will check that we now have a Secret

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Installing the operator

- The official installation is done through a single YAML file

- There is also a Helm chart if you prefer that (see next slide!)

<!-- #VERSION# -->

.lab[

- Install the operator:
  .small[
  ```bash
    kubectl apply -f \
            https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.17.4/controller.yaml
  ```
  ]

]

Note: it installs into `kube-system` by default.

If you change that, you will also need to inform `kubeseal` later on.

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

class: extra-details

## Installing with Helm

- The Sealed Secrets controller can be installed like this:

  ```bash
    helm install --repo https://bitnami-labs.github.io/sealed-secrets/ \
         sealed-secrets-controller sealed-secrets --namespace kube-system
  ```

- Make sure to install in the `kube-system` Namespace

- Make sure that the release is named `sealed-secrets-controller`

  (or pass a `--controller-name` option to `kubeseal` later)

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Creating a Secret

- Let's create a normal (unencrypted) secret

.lab[

- Create a Secret with a couple of API tokens:
  ```bash
    kubectl create secret generic awskey \
            --from-literal=AWS_ACCESS_KEY_ID=AKI... \
            --from-literal=AWS_SECRET_ACCESS_KEY=abc123xyz... \
            --dry-run=client -o yaml > secret-aws.yaml
  ```

]

- Note the `--dry-run` and `-o yaml`

  (we're just generating YAML, not sending the secrets to our Kubernetes cluster)

- We could also write the YAML from scratch or generate it with other tools

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Creating a Sealed Secret

- This is done with the `kubeseal` tool

- It will obtain the public key from the cluster

.lab[

- Create the Sealed Secret:
  ```bash
    kubeseal < secret-aws.yaml > sealed-secret-aws.json
  ```

]

- The file `sealed-secret-aws.json` can be committed to your public repo

  (if you prefer YAML output, you can add `-o yaml`)

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Using a Sealed Secret

- Now let's `kubectl apply` that Sealed Secret to the cluster

- The Sealed Secret controller will "unseal" it for us

.lab[

- Check that our Secret doesn't exist (yet):
  ```bash
  kubectl get secrets
  ```

- Load the Sealed Secret into the cluster:
  ```bash
  kubectl create -f sealed-secret-aws.json
  ```

- Check that the secret is now available:
  ```bash
  kubectl get secrets
  ```

]

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Tweaking secrets

- Let's see what happens if we try to rename the Secret

  (or use it in a different namespace)

.lab[

- Delete both the Secret and the SealedSecret

- Edit `sealed-secret-aws.json`

- Change the name of the secret, or its namespace

  (both in the SealedSecret metadata and in the Secret template)

- `kubectl apply -f` the new JSON file and observe the results 🤔

]

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Sealed Secrets are *scoped*

- A SealedSecret cannot be renamed or moved to another namespace

  (at least, not by default!)

- Otherwise, it would allow to evade RBAC rules:

  - if I can view Secrets in namespace `myapp` but not in namespace `yourapp`

  - I could take a SealedSecret belonging to namespace `yourapp`

  - ... and deploy it in `myapp`

  - ... and view the resulting decrypted Secret!

- This can be changed with `--scope namespace-wide` or `--scope cluster-wide`

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Working offline

- We can obtain the public key from the server

  (technically, as a PEM certificate)

- Then we can use that public key offline

  (without contacting the server)

- Relevant commands:

  `kubeseal --fetch-cert > seal.pem`

  `kubeseal --cert seal.pem < secret.yaml > sealedsecret.json`

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Key rotation

- The controller generate new keys every month by default

- The keys are kept as TLS Secrets in the `kube-system` namespace

  (named `sealed-secrets-keyXXXXX`)

- When keys are "rotated", old decryption keys are kept

  (otherwise we can't decrypt previously-generated SealedSecrets)

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Key compromise

- If the *sealing* key (obtained with `--fetch-cert` is compromised):

  *we don't need to do anything (it's a public key!)*

- However, if the *unsealing* key (the TLS secret in `kube-system`) is compromised ...

  *we need to:*

  - rotate the key

  - rotate the SealedSecrets that were encrypted with that key
    <br/>
    (as they are compromised)

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Rotating the key

- By default, new keys are generated every 30 days

- To force the generation of a new key "right now":

  - obtain an RFC1123 timestamp with `date -R`

  - edit Deployment `sealed-secrets-controller` (in `kube-system`)

  - add `--key-cutoff-time=TIMESTAMP` to the command-line

- *Then*, rotate the SealedSecrets that were encrypted with it

  (generate new Secrets, then encrypt them with the new key)

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Discussion (the good)

- The footprint of the operator is rather small:

  - only one CRD

  - one Deployment, one Service

  - a few RBAC-related objects

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Discussion (the less good)

- Events could be improved

  - `no key to decrypt secret` when there is a name/namespace mismatch

  - no event indicating that a SealedSecret was successfully unsealed

- Key rotation could be improved (how to find secrets corresponding to a key?)

- If the sealing keys are lost, it's impossible to unseal the SealedSecrets

  (e.g. cluster reinstall)

- ... Which means that we need to back up the sealing keys

- ... Which means that we need to be super careful with these backups!

.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

## Other approaches

- [Kamus](https://kamus.soluto.io/) ([git](https://github.com/Soluto/kamus)) offers "zero-trust" secrets

  (the cluster cannot decrypt secrets; only the application can decrypt them)

- [Vault](https://learn.hashicorp.com/tutorials/vault/kubernetes-sidecar?in=vault/kubernetes) can do ... a lot

  - dynamic secrets (generated on the fly for a consumer)

  - certificate management

  - integration outside of Kubernetes

  - and much more!

???

:EN:- The Sealed Secrets Operator
:FR:- L'opérateur *Sealed Secrets*
.debug[[k8s/sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/sealed-secrets.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/container-housing.jpg)]

---

name: toc-custom-resource-definitions
class: title

 Custom Resource Definitions

.nav[
[Previous part](#toc-sealed-secrets)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-exercise--sealed-secrets)
]

.debug[(automatically generated title slide)]

---
# Custom Resource Definitions

- CRDs are one of the (many) ways to extend the API

- CRDs can be defined dynamically

  (no need to recompile or reload the API server)

- A CRD is defined with a CustomResourceDefinition resource

  (CustomResourceDefinition is conceptually similar to a *metaclass*)

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Creating a CRD

- We will create a CRD to represent the different species of coffee

  (arabica, liberica, and robusta)

- We will be able to run `kubectl get coffees` and it will list the species

- Then we can label, edit, etc. the species to attach some information

  (e.g. the taste profile of the coffee, or whatever we want)

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## First shot of coffee

```yaml
# Note: apiextensions.k8s.io/v1beta1 is deprecated, and won't be served
# in Kubernetes 1.22 and later versions. This YAML manifest is here just
# for reference, but it's not intended to be used in modern trainings.
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: coffees.container.training
spec:
  group: container.training
  version: v1alpha1
  scope: Namespaced
  names:
    plural: coffees
    singular: coffee
    kind: Coffee
    shortNames:
    - cof


```

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## The joys of API deprecation

- Unfortunately, the CRD manifest on the previous slide is deprecated!

- It is using `apiextensions.k8s.io/v1beta1`, which is dropped in Kubernetes 1.22

- We need to use `apiextensions.k8s.io/v1`, which is a little bit more complex

  (a few optional things become mandatory, see [this guide](https://kubernetes.io/docs/reference/using-api/deprecation-guide/#customresourcedefinition-v122) for details)

- `apiextensions.k8s.io/v1beta1` is available since Kubernetes 1.16

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Second shot of coffee

- The next slide will show file [k8s/coffee-2.yaml](https://github.com/denisgaudare/container.training/tree/master/k8s/coffee-2.yaml)

- Note the `spec.versions` list

  - we need exactly one version with `storage: true`

  - we can have multiple versions with `served: true`

- `spec.versions[].schema.openAPI3Schema` is required

  (and must be a valid OpenAPI schema; here it's a trivial one)

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: coffees.container.training
spec:
  group: container.training
  versions:
  - name: v1alpha1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object
  scope: Namespaced
  names:
    plural: coffees
    singular: coffee
    kind: Coffee
    shortNames:
    - cof


```

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Creating our Coffee CRD

- Let's create the Custom Resource Definition for our Coffee resource

.lab[

- Load the CRD:
  ```bash
  kubectl apply -f ~/container.training/k8s/coffee-2.yaml
  ```

- Confirm that it shows up:
  ```bash
  kubectl get crds
  ```

]

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Creating custom resources

The YAML below defines a resource using the CRD that we just created:

```yaml
kind: Coffee
apiVersion: container.training/v1alpha1
metadata:
  name: arabica
spec:
  taste: strong
```

.lab[

- Create a few types of coffee beans:
  ```bash
  kubectl apply -f ~/container.training/k8s/coffees.yaml
  ```

]

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Viewing custom resources

- By default, `kubectl get` only shows name and age of custom resources

.lab[

- View the coffee beans that we just created:
  ```bash
  kubectl get coffees
  ```

]

- We'll see in a bit how to improve that

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## What can we do with CRDs?

There are many possibilities!

- *Operators* encapsulate complex sets of resources

  (e.g.: a PostgreSQL replicated cluster; an etcd cluster...
  <br/>
  see [awesome operators](https://github.com/operator-framework/awesome-operators) and
  [OperatorHub](https://operatorhub.io/) to find more)

- Custom use-cases like [gitkube](https://gitkube.sh/)

  - creates a new custom type, `Remote`, exposing a git+ssh server

  - deploy by pushing YAML or Helm charts to that remote

- Replacing built-in types with CRDs

  (see [this lightning talk by Tim Hockin](https://www.youtube.com/watch?v=ji0FWzFwNhA))

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## What's next?

- Creating a basic CRD is quick and easy

- But there is a lot more that we can (and probably should) do:

  - improve input with *data validation*

  - improve output with *custom columns*

- And of course, we probably need a *controller* to go with our CRD!

  (otherwise, we're just using the Kubernetes API as a fancy data store)

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Additional printer columns

- We can specify `additionalPrinterColumns` in the CRD

- This is similar to `-o custom-columns`

  (map a column name to a path in the object, e.g. `.spec.taste`)

```yaml
    additionalPrinterColumns:
    - jsonPath: .spec.taste
      description: Subjective taste of that kind of coffee bean
      name: Taste
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: Age
      type: date
```

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Using additional printer columns

- Let's update our CRD using [k8s/coffee-3.yaml](https://github.com/denisgaudare/container.training/tree/master/k8s/coffee-3.yaml)

.lab[

- Update the CRD:
  ```bash
  kubectl apply -f ~/container.training/k8s/coffee-3.yaml
  ```

- Look at our Coffee resources:
  ```bash
  kubectl get coffees
  ```

]

Note: we can update a CRD without having to re-create the corresponding resources.

(Good news, right?)

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Data validation

- CRDs are validated with the OpenAPI v3 schema that we specify

  (with older versions of the API, when the schema was optional,
  <br/>
  no schema = no validation at all)

- Otherwise, we can put anything we want in the `spec`

- More advanced validation can also be done with admission webhooks, e.g.:

  - consistency between parameters

  - advanced integer filters (e.g. odd number of replicas)

  - things that can change in one direction but not the other

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## OpenAPI v3 schema example

This is what we have in [k8s/coffee-3.yaml](https://github.com/denisgaudare/container.training/tree/master/k8s/coffee-3.yaml):

```yaml
    schema:
      openAPIV3Schema:
        type: object
        required: [ spec ]
        properties:
          spec:
            type: object
            properties:
              taste:
                description: Subjective taste of that kind of coffee bean
                type: string
            required: [ taste ]
```

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Validation *a posteriori*

- Some of the "coffees" that we defined earlier *do not* pass validation

- How is that possible?

--

- Validation happens at *admission*

  (when resources get written into the database)

- Therefore, we can have "invalid" resources in etcd

  (they are invalid from the CRD perspective, but the CRD can be changed)

🤔 How should we handle that ?

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Versions

- If the data format changes, we can roll out a new version of the CRD

  (e.g. go from `v1alpha1` to `v1alpha2`)

- In a CRD we can specify the versions that exist, that are *served*, and *stored*

  - multiple versions can be *served*

  - only one can be *stored*

- Kubernetes doesn't automatically migrate the content of the database

- However, it can convert between versions when resources are read/written

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Conversion

- When *creating* a new resource, the *stored* version is used

  (if we create it with another version, it gets converted)

- When *getting* or *watching* resources, the *requested* version is used

  (if it is stored with another version, it gets converted)

- By default, "conversion" only changes the `apiVersion` field

- ... But we can register *conversion webhooks*

  (see [that doc page](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/#webhook-conversion) for details)

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Migrating database content

- We need to *serve* a version as long as we *store* objects in that version

  (=as long as the database has at least one object with that version)

- If we want to "retire" a version, we need to migrate these objects first

- All we have to do is to read and re-write them

  (the [kube-storage-version-migrator](https://github.com/kubernetes-sigs/kube-storage-version-migrator) tool can help)

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## What's next?

- Generally, when creating a CRD, we also want to run a *controller*

  (otherwise nothing will happen when we create resources of that type)

- The controller will typically *watch* our custom resources

  (and take action when they are created/updated)

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## CRDs in the wild

- [gitkube](https://storage.googleapis.com/gitkube/gitkube-setup-stable.yaml)

- [A redis operator](https://github.com/amaizfinance/redis-operator/blob/master/deploy/crds/k8s_v1alpha1_redis_crd.yaml)

- [cert-manager](https://github.com/jetstack/cert-manager/releases/download/v1.0.4/cert-manager.yaml)

*How big are these YAML files?*

*What's the size (e.g. in lines) of each resource?*

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## CRDs in practice

- Production-grade CRDs can be extremely verbose

  (because of the openAPI schema validation)

- This can (and usually will) be managed by a framework

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

## (Ab)using the API server

- If we need to store something "safely" (as in: in etcd), we can use CRDs

- This gives us primitives to read/write/list objects (and optionally validate them)

- The Kubernetes API server can run on its own

  (without the scheduler, controller manager, and kubelets)

- By loading CRDs, we can have it manage totally different objects

  (unrelated to containers, clusters, etc.)

???

:EN:- Custom Resource Definitions (CRDs)
:FR:- Les CRDs *(Custom Resource Definitions)*

.debug[[k8s/crd.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/crd.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/containers-by-the-water.jpg)]

---

name: toc-exercise--sealed-secrets
class: title

 Exercise — sealed secrets

.nav[
[Previous part](#toc-custom-resource-definitions)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-resource-limits)
]

.debug[(automatically generated title slide)]

---
# Exercise — sealed secrets

This is a "combo exercise" to practice the following concepts:

- Secrets (mounting them in containers)

- RBAC (granting specific permissions to specific users)

- Operators (specifically, sealed secrets)

- Migrations (copying/transferring resources from a cluster to another)

For this exercise, you will need two clusters.

(It can be two local clusters.)

We will call them "source cluster" and "target cluster".

.debug[[k8s/exercise-sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/exercise-sealed-secrets.md)]
---

## Step 1 (easy)

- Install the sealed secrets operator on both clusters

- On source cluster, create a Namespace called `dev`

- Create two sealed secrets, `verysecure` and `veryverysecure`

  (the content doesn't matter; put a random string of your choice)

- Create a Deployment called `app` using both secrets

  (use a mount or environment variables; whatever you prefer!)

- Verify that the secrets are available to the Deployment

.debug[[k8s/exercise-sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/exercise-sealed-secrets.md)]
---

## Step 2 (medium)

- Create another Namespace called `prod`

  (on the source cluster)

- Create the same Deployment `app` using both secrets

- Verify that the secrets are available to the Deployment

.debug[[k8s/exercise-sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/exercise-sealed-secrets.md)]
---

## Step 3 (hard)

- On the target cluster, create a Namespace called `prod`

- Create the `app` Deployment and both sealed secrets

  (do not copy the Secrets; only the sealed secrets)

- Check the next slide if you need a hint!

--

- You will have to copy the Sealed Secret private key

.debug[[k8s/exercise-sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/exercise-sealed-secrets.md)]
---

## Step 4 (medium)

On the target cluster, create the Namespace `dev`.

Let's say that user `alice` has access to the target cluster.

(You can use `kubectl --as=alice` to impersonate her.)

We want Alice to be able to:

- deploy the whole application

- access the `verysecure` secret

- but *not* the `veryverysecure` secret

.debug[[k8s/exercise-sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/exercise-sealed-secrets.md)]
---

## Step 5 (hard)

- Make sure that Alice can view the logs of the Deployment

- Can you think of a way for Alice to access the `veryverysecure` Secret?

  (check next slide for a hint)

--

- `kubectl exec`, maybe?

--

- Can you think of a way to prevent that?

.debug[[k8s/exercise-sealed-secrets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/exercise-sealed-secrets.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/distillery-containers.jpg)]

---

name: toc-resource-limits
class: title

 Resource Limits

.nav[
[Previous part](#toc-exercise--sealed-secrets)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-defining-min-max-and-default-resources)
]

.debug[(automatically generated title slide)]

---
# Resource Limits

- We can attach resource indications to our pods

  (or rather: to the *containers* in our pods)

- We can specify *limits* and/or *requests*

- We can specify quantities of CPU and/or memory

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## CPU vs memory

- CPU is a *compressible resource*

  (it can be preempted immediately without adverse effect)

- Memory is an *incompressible resource*

  (it needs to be swapped out to be reclaimed; and this is costly)

- As a result, exceeding limits will have different consequences for CPU and memory

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Exceeding CPU limits

- CPU can be reclaimed instantaneously

  (in fact, it is preempted hundreds of times per second, at each context switch)

- If a container uses too much CPU, it can be throttled

  (it will be scheduled less often)

- The processes in that container will run slower

  (or rather: they will not run faster)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## CPU limits implementation details

- A container with a CPU limit will be "rationed" by the kernel

- Every `cfs_period_us`, it will receive a CPU quota, like an "allowance"

  (that interval defaults to 100ms)

- Once it has used its quota, it will be stalled until the next period

- This can easily result in throttling for bursty workloads

  (see details on next slide)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## A bursty example

- Web service receives one request per minute

- Each request takes 1 second of CPU

- Average load: 1.66%

- Let's say we set a CPU limit of 10%

- This means CPU quotas of 10ms every 100ms

- Obtaining the quota for 1 second of CPU will take 10 seconds

- Observed latency will be 10 seconds (... actually 9.9s) instead of 1 second

  (real-life scenarios will of course be less extreme, but they do happen!)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## Multi-core scheduling details

- Each core gets a small share of the container's CPU quota

  (this avoids locking and contention on the "global" quota for the container)

- By default, the kernel distributes that quota to CPUs in 5ms increments

  (tunable with `kernel.sched_cfs_bandwidth_slice_us`)

- If a containerized process (or thread) uses up its local CPU quota:

  *it gets more from the "global" container quota (if there's some left)*

- If it "yields" (e.g. sleeps for I/O) before using its local CPU quota:

  *the quota is **soon** returned to the "global" container quota, **minus** 1ms*

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## Low quotas on machines with many cores

- The local CPU quota is not immediately returned to the global quota

  - this reduces locking and contention on the global quota

  - but this can cause starvation when many threads/processes become runnable

- That 1ms that "stays" on the local CPU quota is often useful

  - if the thread/process becomes runnable, it can be scheduled immediately

  - again, this reduces locking and contention on the global quota

  - but if the thread/process doesn't become runnable, it is wasted!

  - this can become a huge problem on machines with many cores

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## CPU limits in a nutshell

- Beware if you run small bursty workloads on machines with many cores!

  ("highly-threaded, user-interactive, non-cpu bound applications")

- Check the `nr_throttled` and `throttled_time` metrics in `cpu.stat`

- Possible solutions/workarounds:

  - be generous with the limits

  - make sure your kernel has the [appropriate patch](https://lkml.org/lkml/2019/5/17/581)

  - use [static CPU manager policy](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#static-policy)

For more details, check [this blog post](https://erickhun.com/posts/kubernetes-faster-services-no-cpu-limits/) or these ones ([part 1](https://engineering.indeedblog.com/blog/2019/12/unthrottled-fixing-cpu-limits-in-the-cloud/), [part 2](https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/)).

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Exceeding memory limits

- Memory needs to be swapped out before being reclaimed

- "Swapping" means writing memory pages to disk, which is very slow

- On a classic system, a process that swaps can get 1000x slower

  (because disk I/O is 1000x slower than memory I/O)

- Exceeding the memory limit (even by a small amount) can reduce performance *a lot*

- Kubernetes *does not support swap* (more on that later!)

- Exceeding the memory limit will cause the container to be killed

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Limits vs requests

- Limits are "hard limits" (they can't be exceeded)

  - a container exceeding its memory limit is killed

  - a container exceeding its CPU limit is throttled

- Requests are used for scheduling purposes

  - a container using *less* than what it requested will never be killed or throttled

  - the scheduler uses the requested sizes to determine placement

  - the resources requested by all pods on a node will never exceed the node size

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Pod quality of service

Each pod is assigned a QoS class (visible in `status.qosClass`).

- If limits = requests:

  - as long as the container uses less than the limit, it won't be affected

  - if all containers in a pod have *(limits=requests)*, QoS is considered "Guaranteed"

- If requests &lt; limits:

  - as long as the container uses less than the request, it won't be affected

  - otherwise, it might be killed/evicted if the node gets overloaded

  - if at least one container has *(requests&lt;limits)*, QoS is considered "Burstable"

- If a pod doesn't have any request nor limit, QoS is considered "BestEffort"

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Quality of service impact

- When a node is overloaded, BestEffort pods are killed first

- Then, Burstable pods that exceed their requests

- Burstable and Guaranteed pods below their requests are never killed

  (except if their node fails)

- If we only use Guaranteed pods, no pod should ever be killed

  (as long as they stay within their limits)

(Pod QoS is also explained in [this page](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/) of the Kubernetes documentation and in [this blog post](https://medium.com/google-cloud/quality-of-service-class-qos-in-kubernetes-bb76a89eb2c6).)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Where is my swap?

- The semantics of memory and swap limits on Linux cgroups are complex

- With cgroups v1, it's not possible to disable swap for a cgroup

  (the closest option is to [reduce "swappiness"](https://unix.stackexchange.com/questions/77939/turning-off-swapping-for-only-one-process-with-cgroups))

- It is possible with cgroups v2 (see the [kernel docs](https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html) and the [fbatx docs](https://facebookmicrosites.github.io/cgroup2/docs/memory-controller.html#using-swap))

- Cgroups v2 aren't widely deployed yet

- The architects of Kubernetes wanted to ensure that Guaranteed pods never swap

- The simplest solution was to disable swap entirely

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Alternative point of view

- Swap enables paging¹ of anonymous² memory

- Even when swap is disabled, Linux will still page memory for:

  - executables, libraries

  - mapped files

- Disabling swap *will reduce performance and available resources*

- For a good time, read [kubernetes/kubernetes#53533](https://github.com/kubernetes/kubernetes/issues/53533)

- Also read this [excellent blog post about swap](https://jvns.ca/blog/2017/02/17/mystery-swap/)

¹Paging: reading/writing memory pages from/to disk to reclaim physical memory

²Anonymous memory: memory that is not backed by files or blocks

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Enabling swap anyway

- If you don't care that pods are swapping, you can enable swap

- You will need to add the flag `--fail-swap-on=false` to kubelet

  (otherwise, it won't start!)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Specifying resources

- Resource requests are expressed at the *container* level

- CPU is expressed in "virtual CPUs"

  (corresponding to the virtual CPUs offered by some cloud providers)

- CPU can be expressed with a decimal value, or even a "milli" suffix

  (so 100m = 0.1)

- Memory is expressed in bytes

- Memory can be expressed with k, M, G, T, ki, Mi, Gi, Ti suffixes

  (corresponding to 10^3, 10^6, 10^9, 10^12, 2^10, 2^20, 2^30, 2^40)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Specifying resources in practice

This is what the spec of a Pod with resources will look like:

```yaml
containers:
- name: httpenv
  image: jpetazzo/httpenv
  resources:
    limits:
      memory: "100Mi"
      cpu: "100m"
    requests:
      memory: "100Mi"
      cpu: "10m"
```

This set of resources makes sure that this service won't be killed (as long as it stays below 100 MB of RAM), but allows its CPU usage to be throttled if necessary.

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Default values

- If we specify a limit without a request: 

  the request is set to the limit

- If we specify a request without a limit: 

  there will be no limit

  (which means that the limit will be the size of the node)

- If we don't specify anything:

  the request is zero and the limit is the size of the node

*Unless there are default values defined for our namespace!*

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## We need default resource values

- If we do not set resource values at all:

  - the limit is "the size of the node"

  - the request is zero

- This is generally *not* what we want

  - a container without a limit can use up all the resources of a node

  - if the request is zero, the scheduler can't make a smart placement decision

- To address this, we can set default values for resources

- This is done with a LimitRange object

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/lots-of-containers.jpg)]

---

name: toc-defining-min-max-and-default-resources
class: title

 Defining min, max, and default resources

.nav[
[Previous part](#toc-resource-limits)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-namespace-quotas)
]

.debug[(automatically generated title slide)]

---

# Defining min, max, and default resources

- We can create LimitRange objects to indicate any combination of:

  - min and/or max resources allowed per pod

  - default resource *limits*

  - default resource *requests*

  - maximal burst ratio (*limit/request*)

- LimitRange objects are namespaced

- They apply to their namespace only

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## LimitRange example

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: my-very-detailed-limitrange
spec:
  limits:
  - type: Container
    min:
      cpu: "100m"
    max:
      cpu: "2000m"
      memory: "1Gi"
    default:
      cpu: "500m"
      memory: "250Mi"
    defaultRequest:
      cpu: "500m"
```

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Example explanation

The YAML on the previous slide shows an example LimitRange object specifying very detailed limits on CPU usage,
and providing defaults on RAM usage.

Note the `type: Container` line: in the future,
it might also be possible to specify limits
per Pod, but it's not [officially documented yet](https://github.com/kubernetes/website/issues/9585).

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## LimitRange details

- LimitRange restrictions are enforced only when a Pod is created

  (they don't apply retroactively)

- They don't prevent creation of e.g. an invalid Deployment or DaemonSet

  (but the pods will not be created as long as the LimitRange is in effect)

- If there are multiple LimitRange restrictions, they all apply together

  (which means that it's possible to specify conflicting LimitRanges,
  <br/>preventing any Pod from being created)

- If a LimitRange specifies a `max` for a resource but no `default`,
  <br/>that `max` value becomes the `default` limit too

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/plastic-containers.JPG)]

---

name: toc-namespace-quotas
class: title

 Namespace quotas

.nav[
[Previous part](#toc-defining-min-max-and-default-resources)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-limiting-resources-in-practice)
]

.debug[(automatically generated title slide)]

---

# Namespace quotas

- We can also set quotas per namespace

- Quotas apply to the total usage in a namespace

  (e.g. total CPU limits of all pods in a given namespace)

- Quotas can apply to resource limits and/or requests

  (like the CPU and memory limits that we saw earlier)

- Quotas can also apply to other resources:

  - "extended" resources (like GPUs)

  - storage size

  - number of objects (number of pods, services...)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Creating a quota for a namespace

- Quotas are enforced by creating a ResourceQuota object

- ResourceQuota objects are namespaced, and apply to their namespace only

- We can have multiple ResourceQuota objects in the same namespace

- The most restrictive values are used

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Limiting total CPU/memory usage

- The following YAML specifies an upper bound for *limits* and *requests*:
  ```yaml
    apiVersion: v1
    kind: ResourceQuota
    metadata:
      name: a-little-bit-of-compute
    spec:
      hard:
        requests.cpu: "10"
        requests.memory: 10Gi
        limits.cpu: "20"
        limits.memory: 20Gi
  ```

These quotas will apply to the namespace where the ResourceQuota is created.

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Limiting number of objects

- The following YAML specifies how many objects of specific types can be created:
  ```yaml
    apiVersion: v1
    kind: ResourceQuota
    metadata:
      name: quota-for-objects
    spec:
      hard:
        pods: 100
        services: 10
        secrets: 10
        configmaps: 10
        persistentvolumeclaims: 20
        services.nodeports: 0
        services.loadbalancers: 0
        count/roles.rbac.authorization.k8s.io: 10
  ```

(The `count/` syntax allows limiting arbitrary objects, including CRDs.)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## YAML vs CLI

- Quotas can be created with a YAML definition

- ...Or with the `kubectl create quota` command

- Example:
  ```bash
  kubectl create quota my-resource-quota --hard=pods=300,limits.memory=300Gi
  ```

- With both YAML and CLI form, the values are always under the `hard` section

  (there is no `soft` quota)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Viewing current usage

When a ResourceQuota is created, we can see how much of it is used:

```
kubectl describe resourcequota my-resource-quota

Name:                            my-resource-quota
Namespace:                       default
Resource                         Used  Hard
--------                         ----  ----
pods                             12    100
services                         1     5
services.loadbalancers           0     0
services.nodeports               0     0
```

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Advanced quotas and PriorityClass

- Pods can have a *priority*

- The priority is a number from 0 to 1000000000

  (or even higher for system-defined priorities)

- High number = high priority = "more important" Pod

- Pods with a higher priority can *preempt* Pods with lower priority

  (= low priority pods will be *evicted* if needed)

- Useful when mixing workloads in resource-constrained environments

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Setting the priority of a Pod

- Create a PriorityClass

  (or use an existing one)

- When creating the Pod, set the field `spec.priorityClassName`

- If the field is not set:

  - if there is a PriorityClass with `globalDefault`, it is used

  - otherwise, the default priority will be zero

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## PriorityClass and ResourceQuotas

- A ResourceQuota can include a list of *scopes* or a *scope selector*

- In that case, the quota will only apply to the scoped resources

- Example: limit the resources allocated to "high priority" Pods

- In that case, make sure that the quota is created in every Namespace

  (or use *admission configuration* to enforce it)

- See the [resource quotas documentation][quotadocs] for details

[quotadocs]: https://kubernetes.io/docs/concepts/policy/resource-quotas/#resource-quota-per-priorityclass

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/train-of-containers-1.jpg)]

---

name: toc-limiting-resources-in-practice
class: title

 Limiting resources in practice

.nav[
[Previous part](#toc-namespace-quotas)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-checking-node-and-pod-resource-usage)
]

.debug[(automatically generated title slide)]

---

# Limiting resources in practice

- We have at least three mechanisms:

  - requests and limits per Pod

  - LimitRange per namespace

  - ResourceQuota per namespace

- Let's see a simple recommendation to get started with resource limits

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Set a LimitRange

- In each namespace, create a LimitRange object

- Set a small default CPU request and CPU limit

  (e.g. "100m")

- Set a default memory request and limit depending on your most common workload

  - for Java, Ruby: start with "1G"

  - for Go, Python, PHP, Node: start with "250M"

- Set upper bounds slightly below your expected node size

  (80-90% of your node size, with at least a 500M memory buffer)

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Set a ResourceQuota

- In each namespace, create a ResourceQuota object

- Set generous CPU and memory limits

  (e.g. half the cluster size if the cluster hosts multiple apps)

- Set generous objects limits

  - these limits should not be here to constrain your users

  - they should catch a runaway process creating many resources

  - example: a custom controller creating many pods

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Observe, refine, iterate

- Observe the resource usage of your pods

  (we will see how in the next chapter)

- Adjust individual pod limits

- If you see trends: adjust the LimitRange

  (rather than adjusting every individual set of pod limits)

- Observe the resource usage of your namespaces

  (with `kubectl describe resourcequota ...`)

- Rinse and repeat regularly

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Viewing a namespace limits and quotas

- `kubectl describe namespace` will display resource limits and quotas

.lab[

- Try it out:
  ```bash
  kubectl describe namespace default
  ```

- View limits and quotas for *all* namespaces:
  ```bash
  kubectl describe namespace
  ```

]

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Additional resources

- [A Practical Guide to Setting Kubernetes Requests and Limits](http://blog.kubecost.com/blog/requests-and-limits/)

  - explains what requests and limits are

  - provides guidelines to set requests and limits

  - gives PromQL expressions to compute good values
    <br/>(our app needs to be running for a while)

- [Kube Resource Report](https://github.com/hjacobs/kube-resource-report/)

  - generates web reports on resource usage

  - [static demo](https://hjacobs.github.io/kube-resource-report/sample-report/output/index.html)
    |
    [live demo](https://kube-resource-report.demo.j-serv.de/applications.html)

???

:EN:- Setting compute resource limits
:EN:- Defining default policies for resource usage
:EN:- Managing cluster allocation and quotas
:EN:- Resource management in practice

:FR:- Allouer et limiter les ressources des conteneurs
:FR:- Définir des ressources par défaut
:FR:- Gérer les quotas de ressources au niveau du cluster
:FR:- Conseils pratiques

.debug[[k8s/resource-limits.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/train-of-containers-2.jpg)]

---

name: toc-checking-node-and-pod-resource-usage
class: title

 Checking Node and Pod resource usage

.nav[
[Previous part](#toc-limiting-resources-in-practice)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-cluster-sizing)
]

.debug[(automatically generated title slide)]

---
# Checking Node and Pod resource usage

- We've installed a few things on our cluster so far

- How much resources (CPU, RAM) are we using?

- We need metrics!

.lab[

- Let's try the following command:
  ```bash
  kubectl top nodes
  ```
]

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Is metrics-server installed?

- If we see a list of nodes, with CPU and RAM usage:

  *great, metrics-server is installed!*

- If we see `error: Metrics API not available`:

  *metrics-server isn't installed, so we'll install it!*

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## The resource metrics pipeline

- The `kubectl top` command relies on the Metrics API

- The Metrics API is part of the "[resource metrics pipeline]"

- The Metrics API isn't served (built into) the Kubernetes API server

- It is made available through the [aggregation layer]

- It is usually served by a component called metrics-server

- It is optional (Kubernetes can function without it)

- It is necessary for some features (like the Horizontal Pod Autoscaler)

[resource metrics pipeline]: https://kubernetes.io/docs/tasks/debug-application-cluster/resource-metrics-pipeline/
[aggregation layer]: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Other ways to get metrics

- We could use a SAAS like Datadog, New Relic...

- We could use a self-hosted solution like Prometheus

- Or we could use metrics-server

- What's special about metrics-server?

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Pros/cons

Cons:

- no data retention (no history data, just instant numbers)

- only CPU and RAM of nodes and pods (no disk or network usage or I/O...)

Pros:

- very lightweight

- doesn't require storage

- used by Kubernetes autoscaling

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Why metrics-server

- We may install something fancier later

  (think: Prometheus with Grafana)

- But metrics-server will work in *minutes*

- It will barely use resources on our cluster

- It's required for autoscaling anyway

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## How metric-server works

- It runs a single Pod

- That Pod will fetch metrics from all our Nodes

- It will expose them through the Kubernetes API agregation layer

  (we won't say much more about that agregation layer; that's fairly advanced stuff!)

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Installing metrics-server

- In a lot of places, this is done with a little bit of custom YAML

  (derived from the [official installation instructions](https://github.com/kubernetes-sigs/metrics-server#installation))

- We're going to use Helm one more time:
  ```bash
    helm upgrade --install metrics-server bitnami/metrics-server \
      --create-namespace --namespace metrics-server \
      --set apiService.create=true \
      --set extraArgs.kubelet-insecure-tls=true \
      --set extraArgs.kubelet-preferred-address-types=InternalIP
  ```

- What are these options for?

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Installation options

- `apiService.create=true`

  register `metrics-server` with the Kubernetes agregation layer

  (create an entry that will show up in `kubectl get apiservices`)

- `extraArgs.kubelet-insecure-tls=true`

  when connecting to nodes to collect their metrics, don't check kubelet TLS certs

  (because most kubelet certs include the node name, but not its IP address)

- `extraArgs.kubelet-preferred-address-types=InternalIP`

  when connecting to nodes, use their internal IP address instead of node name

  (because the latter requires an internal DNS, which is rarely configured)

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Testing metrics-server

- After a minute or two, metrics-server should be up

- We should now be able to check Nodes resource usage:
  ```bash
  kubectl top nodes
  ```

- And Pods resource usage, too:
  ```bash
  kubectl top pods --all-namespaces
  ```

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Keep some padding

- The RAM usage that we see should correspond more or less to the Resident Set Size

- Our pods also need some extra space for buffers, caches...

- Do not aim for 100% memory usage!

- Some more realistic targets:

  50% (for workloads with disk I/O and leveraging caching)

  90% (on very big nodes with mostly CPU-bound workloads)

  75% (anywhere in between!)

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Other tools

- kube-capacity is a great CLI tool to view resources

  (https://github.com/robscott/kube-capacity)

- It can show resource and limits, and compare them with usage

- It can show utilization per node, or per pod

- kube-resource-report can generate HTML reports

  (https://github.com/hjacobs/kube-resource-report)

???

:EN:- The resource metrics pipeline
:EN:- Installing metrics-server

:EN:- Le *resource metrics pipeline*
:FR:- Installtion de metrics-server

.debug[[k8s/metrics-server.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/two-containers-on-a-truck.jpg)]

---

name: toc-cluster-sizing
class: title

 Cluster sizing

.nav[
[Previous part](#toc-checking-node-and-pod-resource-usage)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-the-horizontal-pod-autoscaler)
]

.debug[(automatically generated title slide)]

---
# Cluster sizing

- What happens when the cluster gets full?

- How can we scale up the cluster?

- Can we do it automatically?

- What are other methods to address capacity planning?

.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## When are we out of resources?

- kubelet monitors node resources:

  - memory

  - node disk usage (typically the root filesystem of the node)

  - image disk usage (where container images and RW layers are stored)

- For each resource, we can provide two thresholds:

  - a hard threshold (if it's met, it provokes immediate action)

  - a soft threshold (provokes action only after a grace period)

- Resource thresholds and grace periods are configurable

  (by passing kubelet command-line flags)

.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## What happens then?

- If disk usage is too high:

  - kubelet will try to remove terminated pods

  - then, it will try to *evict* pods

- If memory usage is too high:

  - it will try to evict pods

- The node is marked as "under pressure"

- This temporarily prevents new pods from being scheduled on the node

.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## Which pods get evicted?

- kubelet looks at the pods' QoS and PriorityClass

- First, pods with BestEffort QoS are considered

- Then, pods with Burstable QoS exceeding their *requests*

  (but only if the exceeding resource is the one that is low on the node)

- Finally, pods with Guaranteed QoS, and Burstable pods within their requests

- Within each group, pods are sorted by PriorityClass

- If there are pods with the same PriorityClass, they are sorted by usage excess

  (i.e. the pods whose usage exceeds their requests the most are evicted first)

.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

class: extra-details

## Eviction of Guaranteed pods

- *Normally*, pods with Guaranteed QoS should not be evicted

- A chunk of resources is reserved for node processes (like kubelet)

- It is expected that these processes won't use more than this reservation

- If they do use more resources anyway, all bets are off!

- If this happens, kubelet must evict Guaranteed pods to preserve node stability

  (or Burstable pods that are still within their requested usage)

.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## What happens to evicted pods?

- The pod is terminated

- It is marked as `Failed` at the API level

- If the pod was created by a controller, the controller will recreate it

- The pod will be recreated on another node, *if there are resources available!*

- For more details about the eviction process, see:

  - [this documentation page](https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/) about resource pressure and pod eviction,

  - [this other documentation page](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/) about pod priority and preemption.

.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## What if there are no resources available?

- Sometimes, a pod cannot be scheduled anywhere:

  - all the nodes are under pressure,

  - or the pod requests more resources than are available

- The pod then remains in `Pending` state until the situation improves

.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## Cluster scaling

- One way to improve the situation is to add new nodes

- This can be done automatically with the [Cluster Autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler)

- The autoscaler will automatically scale up:

  - if there are pods that failed to be scheduled

- The autoscaler will automatically scale down:

  - if nodes have a low utilization for an extended period of time

.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## Restrictions, gotchas ...

- The Cluster Autoscaler only supports a few cloud infrastructures

  (see [here](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/cloudprovider) for a list)

- The Cluster Autoscaler cannot scale down nodes that have pods using:

  - local storage

  - affinity/anti-affinity rules preventing them from being rescheduled

  - a restrictive PodDisruptionBudget

.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## Other way to do capacity planning

- "Running Kubernetes without nodes"

- Systems like [Virtual Kubelet](https://virtual-kubelet.io/) or [Kiyot](https://static.elotl.co/docs/latest/kiyot/kiyot.html) can run pods using on-demand resources

  - Virtual Kubelet can leverage e.g. ACI or Fargate to run pods

  - Kiyot runs pods in ad-hoc EC2 instances (1 instance per pod)

- Economic advantage (no wasted capacity)

- Security advantage (stronger isolation between pods)

Check [this blog post](http://jpetazzo.github.io/2019/02/13/running-kubernetes-without-nodes-with-kiyot/) for more details.

???

:EN:- What happens when the cluster is at, or over, capacity
:EN:- Cluster sizing and scaling

:FR:- Ce qui se passe quand il n'y a plus assez de ressources
:FR:- Dimensionner et redimensionner ses clusters


.debug[[k8s/cluster-sizing.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/wall-of-containers.jpeg)]

---

name: toc-the-horizontal-pod-autoscaler
class: title

 The Horizontal Pod Autoscaler

.nav[
[Previous part](#toc-cluster-sizing)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-the-aggregation-layer)
]

.debug[(automatically generated title slide)]

---
# The Horizontal Pod Autoscaler

- What is the Horizontal Pod Autoscaler, or HPA?

- It is a controller that can perform *horizontal* scaling automatically

- Horizontal scaling = changing the number of replicas

  (adding/removing pods)

- Vertical scaling = changing the size of individual replicas

  (increasing/reducing CPU and RAM per pod)

- Cluster scaling = changing the size of the cluster

  (adding/removing nodes)

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Principle of operation

- Each HPA resource (or "policy") specifies:

  - which object to monitor and scale (e.g. a Deployment, ReplicaSet...)

  - min/max scaling ranges (the max is a safety limit!)

  - a target resource usage (e.g. the default is CPU=80%)

- The HPA continuously monitors the CPU usage for the related object

- It computes how many pods should be running:

  `TargetNumOfPods = ceil(sum(CurrentPodsCPUUtilization) / Target)`

- It scales the related object up/down to this target number of pods

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Pre-requirements

- The metrics server needs to be running

  (i.e. we need to be able to see pod metrics with `kubectl top pods`)

- The pods that we want to autoscale need to have resource requests

  (because the target CPU% is not absolute, but relative to the request)

- The latter actually makes a lot of sense:

  - if a Pod doesn't have a CPU request, it might be using 10% of CPU...

  - ...but only because there is no CPU time available!

  - this makes sure that we won't add pods to nodes that are already resource-starved

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Testing the HPA

- We will start a CPU-intensive web service

- We will send some traffic to that service

- We will create an HPA policy

- The HPA will automatically scale up the service for us

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## A CPU-intensive web service

- Let's use `jpetazzo/busyhttp`

  (it is a web server that will use 1s of CPU for each HTTP request)

.lab[

- Deploy the web server:
  ```bash
  kubectl create deployment busyhttp --image=jpetazzo/busyhttp
  ```

- Expose it with a ClusterIP service:
  ```bash
  kubectl expose deployment busyhttp --port=80
  ```

- Get the ClusterIP allocated to the service:
  ```bash
  kubectl get svc busyhttp
  ```

]

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Monitor what's going on

- Let's start a bunch of commands to watch what is happening

.lab[

- Monitor pod CPU usage:
  ```bash
  watch kubectl top pods -l app=busyhttp
  ```

<!--
```wait NAME```
```tmux split-pane -v```
```bash CLUSTERIP=$(kubectl get svc busyhttp -o jsonpath={.spec.clusterIP})```
-->

- Monitor service latency:
  ```bash
  httping http://`$CLUSTERIP`/
  ```

<!--
```wait connected to```
```tmux split-pane -v```
-->

- Monitor cluster events:
  ```bash
  kubectl get events -w
  ```

<!--
```wait Normal```
```tmux split-pane -v```
```bash CLUSTERIP=$(kubectl get svc busyhttp -o jsonpath={.spec.clusterIP})```
-->

]

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Send traffic to the service

- We will use `ab` (Apache Bench) to send traffic

.lab[

- Send a lot of requests to the service, with a concurrency level of 3:
  ```bash
  ab -c 3 -n 100000 http://`$CLUSTERIP`/
  ```

<!--
```wait be patient```
```tmux split-pane -v```
```tmux selectl even-vertical```
-->

]

The latency (reported by `httping`) should increase above 3s.

The CPU utilization should increase to 100%.

(The server is single-threaded and won't go above 100%.)

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Create an HPA policy

- There is a helper command to do that for us: `kubectl autoscale`

.lab[

- Create the HPA policy for the `busyhttp` deployment:
  ```bash
  kubectl autoscale deployment busyhttp --max=10
  ```

]

By default, it will assume a target of 80% CPU usage.

This can also be set with `--cpu-percent=`.

--

*The autoscaler doesn't seem to work. Why?*

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## What did we miss?

- The events stream gives us a hint, but to be honest, it's not very clear:

  `missing request for cpu`

- We forgot to specify a resource request for our Deployment!

- The HPA target is not an absolute CPU%

- It is relative to the CPU requested by the pod

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Adding a CPU request

- Let's edit the deployment and add a CPU request

- Since our server can use up to 1 core, let's request 1 core

.lab[

- Edit the Deployment definition:
  ```bash
  kubectl edit deployment busyhttp
  ```

<!--
```wait Please edit```
```keys /resources```
```key ^J```
```keys $xxxo  requests:```
```key ^J```
```key Space```
```key Space```
```keys cpu: "1"```
```key Escape```
```keys :wq```
```key ^J```
-->

- In the `containers` list, add the following block:
  ```yaml
    resources:
      requests:
        cpu: "1"
  ```

]

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Results

- After saving and quitting, a rolling update happens

  (if `ab` or `httping` exits, make sure to restart it)

- It will take a minute or two for the HPA to kick in:

  - the HPA runs every 30 seconds by default

  - it needs to gather metrics from the metrics server first

- If we scale further up (or down), the HPA will react after a few minutes:

  - it won't scale up if it already scaled in the last 3 minutes

  - it won't scale down if it already scaled in the last 5 minutes

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## What about other metrics?

- The HPA in API group `autoscaling/v1` only supports CPU scaling

- The HPA in API group `autoscaling/v2beta2` supports metrics from various API groups:

  - metrics.k8s.io, aka metrics server (per-Pod CPU and RAM)

  - custom.metrics.k8s.io, custom metrics per Pod

  - external.metrics.k8s.io, external metrics (not associated to Pods)

- Kubernetes doesn't implement any of these API groups

- Using these metrics requires [registering additional APIs](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-metrics-apis)

- The metrics provided by metrics server are standard; everything else is custom

- For more details, see [this great blog post](https://medium.com/uptime-99/kubernetes-hpa-autoscaling-with-custom-and-external-metrics-da7f41ff7846) or [this talk](https://www.youtube.com/watch?v=gSiGFH4ZnS8)

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Cleanup

- Since `busyhttp` uses CPU cycles, let's stop it before moving on

.lab[

- Delete the `busyhttp` Deployment:
  ```bash
  kubectl delete deployment busyhttp
  ```

<!--
```key ^D```
```key ^C```
```key ^D```
```key ^C```
```key ^D```
```key ^C```
```key ^D```
```key ^C```
-->

]

???

:EN:- Auto-scaling resources
:FR:- *Auto-scaling* (dimensionnement automatique) des ressources

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-the-aggregation-layer
class: title

 The Aggregation Layer

.nav[
[Previous part](#toc-the-horizontal-pod-autoscaler)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-collecting-metrics-with-prometheus)
]

.debug[(automatically generated title slide)]

---
# The Aggregation Layer

- The aggregation layer is a way to extend the Kubernetes API

- It is similar to CRDs

  - it lets us define new resource types

  - these resources can then be used with `kubectl` and other clients

- The implementation is very different

  - CRDs are handled within the API server

  - the aggregation layer offloads requests to another process

- They are designed for very different use-cases

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## CRDs vs aggregation layer

- The Kubernetes API is a REST-ish API with a hierarchical structure

- It can be extended with Custom Resource Definifions (CRDs)

- Custom resources are managed by the Kubernetes API server

  - we don't need to write code

  - the API server does all the heavy lifting

  - these resources are persisted in Kubernetes' "standard" database
    <br/>
    (for most installations, that's `etcd`)

- We can also define resources that are *not* managed by the API server

  (the API server merely proxies the requests to another server)

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## Which one is best?

- For things that "map" well to objects stored in a traditional database:

  *probably CRDs*

- For things that "exist" only in Kubernetes and don't represent external resources:

  *probably CRDs*

- For things that are read-only, at least from Kubernetes' perspective:

  *probably aggregation layer*

- For things that can't be stored in etcd because of size or access patterns:

  *probably aggregation layer*

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## How are resources organized?

- Let's have a look at the Kubernetes API hierarchical structure

- We'll ask `kubectl` to show us the exacts requests that it's making

.lab[

- Check the URI for a cluster-scope, "core" resource, e.g. a Node:
  ```bash
  kubectl -v6 get node node1
  ```

- Check the URI for a cluster-scope, "non-core" resource, e.g. a ClusterRole:
  ```bash
  kubectl -v6 get clusterrole view
  ```

]

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## Core vs non-core

- This is the structure of the URIs that we just checked:

  ```
    /api/v1/nodes/node1
         ↑    ↑     ↑
     `version` `kind` `name`

    /apis/rbac.authorization.k8s.io/v1/clusterroles/view
                        ↑           ↑        ↑       ↑
                      `group`      `version`   `kind`    `name`
  ```

- There is no group for "core" resources

- Or, we could say that the group, `core`, is implied

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## Group-Version-Kind

- In the API server, the Group-Version-Kind triple maps to a Go type

  (look for all the "GVK" occurrences in the source code!)

- In the API server URI router, the GVK is parsed "relatively early"

  (so that the server can know which resource we're talking about)

- "Well, actually ..." Things are a bit more complicated, see next slides!

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

class: extra-details

## Namespaced resources

- What about namespaced resources?

.lab[

- Check the URI for a namespaced, "core" resource, e.g. a Service:
  ```bash
  kubectl -v6 get service kubernetes --namespace default
  ```

]

- Here are what namespaced resources URIs look like:

  ```
    /api/v1/namespaces/default/services/kubernetes
         ↑               ↑        ↑         ↑
      `version`        `namespace`  `kind`      `name`

    /apis/apps/v1/namespaces/kube-system/daemonsets/kube-proxy
           ↑   ↑                 ↑           ↑          ↑
       `group`  `version`        `namespace`     `kind`       `name`
  ```

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

class: extra-details

## Subresources

- Many resources have *subresources*, for instance:

  - `/status` (decouples status updates from other updates)

  - `/scale` (exposes a consistent interface for autoscalers)

  - `/proxy` (allows access to HTTP resources)

  - `/portforward` (used by `kubectl port-forward`)

  - `/logs` (access pod logs)

- These are added at the end of the URI

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

class: extra-details

## Accessing a subresource

.lab[

- List `kube-proxy` pods:
  ```bash
    kubectl get pods --namespace=kube-system --selector=k8s-app=kube-proxy
    PODNAME=$(
      kubectl get pods --namespace=kube-system --selector=k8s-app=kube-proxy \
              -o json | jq -r .items[0].metadata.name)
  ```

- Execute a command in a pod, showing the API requests:
  ```bash
  kubectl -v6 exec --namespace=kube-system $PODNAME -- echo hello world
  ```

]

--

The full request looks like:
```
POST https://.../api/v1/namespaces/kube-system/pods/kube-proxy-c7rlw/exec?
command=echo&command=hello&command=world&container=kube-proxy&stderr=true&stdout=true
```

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## Listing what's supported on the server

- There are at least three useful commands to introspect the API server

.lab[

- List resources types, their group, kind, short names, and scope:
  ```bash
  kubectl api-resources
  ```

- List API groups + versions:
  ```bash
  kubectl api-versions
  ```

- List APIServices:
  ```bash
  kubectl get apiservices
  ```

]

--

🤔 What's the difference between the last two?

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## API registration

- `kubectl api-versions` shows all API groups, including `apiregistration.k8s.io`

- `kubectl get apiservices` shows the "routing table" for API requests

- The latter doesn't show `apiregistration.k8s.io`

  (APIServices belong to `apiregistration.k8s.io`)

- Most API groups are `Local` (handled internally by the API server)

- If we're running the `metrics-server`, it should handle `metrics.k8s.io`

- This is an API group handled *outside* of the API server

- This is the *aggregation layer!*

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## Finding resources

The following assumes that `metrics-server` is deployed on your cluster.

.lab[

- Check that the metrics.k8s.io is registered with `metrics-server`:
  ```bash
  kubectl get apiservices | grep metrics.k8s.io
  ```

- Check the resource kinds registered in the metrics.k8s.io group:
  ```bash
  kubectl api-resources --api-group=metrics.k8s.io
  ```

]

(If the output of either command is empty, install `metrics-server` first.)

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## `nodes` vs `nodes`

- We can have multiple resources with the same name

.lab[

- Look for resources named `node`:
  ```bash
  kubectl api-resources | grep -w nodes
  ```

- Compare the output of both commands:
  ```bash
  kubectl get nodes
  kubectl get nodes.metrics.k8s.io
  ```

]

--

🤔 What are the second kind of nodes? How can we see what's really in them?

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## Node vs NodeMetrics

- `nodes.metrics.k8s.io` (aka NodeMetrics) don't have fancy *printer columns*

- But we can look at the raw data (with `-o json` or `-o yaml`)

.lab[

- Look at NodeMetrics objects with one of these commands:
  ```bash
  kubectl get -o yaml nodes.metrics.k8s.io
  kubectl get -o yaml NodeMetrics
  ```

]

--

💡 Alright, these are the live metrics (CPU, RAM) for our nodes.

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## An easier way to consume metrics

- We might have seen these metrics before ... With an easier command!

--

.lab[

- Display node metrics:
  ```bash
  kubectl top nodes
  ```

- Check which API requests happen behind the scenes:
  ```bash
  kubectl top nodes -v6
  ```

]

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## Aggregation layer in practice

- We can write an API server to handle a subset of the Kubernetes API

- Then we can register that server by creating an APIService resource

.lab[

- Check the definition used for the `metrics-server`:
  ```bash
  kubectl describe apiservices v1beta1.metrics.k8s.io
  ```
]

- Group priority is used when multiple API groups provide similar kinds

  (e.g. `nodes` and `nodes.metrics.k8s.io` as seen earlier)

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## Authentication flow

- We have two Kubernetes API servers:
 
  - "aggregator" (the main one; clients connect to it)

  - "aggregated" (the one providing the extra API; aggregator connects to it)

- Aggregator deals with client authentication

- Aggregator authenticates with aggregated using mutual TLS

- Aggregator passes (/forwards/proxies/...) requests to aggregated

- Aggregated performs authorization by calling back aggregator

  ("can subject X perform action Y on resource Z?")

[This doc page](https://kubernetes.io/docs/tasks/extend-kubernetes/configure-aggregation-layer/#authentication-flow) has very nice swim lanes showing that flow.

.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

## Discussion

- Aggregation layer is great for metrics

  (fast-changing, ephemeral data, that would be outrageously bad for etcd)

- It *could* be a good fit to expose other REST APIs as a pass-thru 

  (but it's more common to see CRDs instead)

???

:EN:- The aggregation layer
:FR:- Étendre l'API avec le *aggregation layer*
.debug[[k8s/aggregation-layer.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/aggregation-layer.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/ShippingContainerSFBay.jpg)]

---

name: toc-collecting-metrics-with-prometheus
class: title

 Collecting metrics with Prometheus

.nav[
[Previous part](#toc-the-aggregation-layer)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-scaling-with-custom-metrics)
]

.debug[(automatically generated title slide)]

---
# Collecting metrics with Prometheus

- Prometheus is an open-source monitoring system including:

  - multiple *service discovery* backends to figure out which metrics to collect

  - a *scraper* to collect these metrics

  - an efficient *time series database* to store these metrics

  - a specific query language (PromQL) to query these time series

  - an *alert manager* to notify us according to metrics values or trends

- We are going to use it to collect and query some metrics on our Kubernetes cluster

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Why Prometheus?

- We don't endorse Prometheus more or less than any other system

- It's relatively well integrated within the cloud-native ecosystem

- It can be self-hosted (this is useful for tutorials like this)

- It can be used for deployments of varying complexity:

  - one binary and 10 lines of configuration to get started

  - all the way to thousands of nodes and millions of metrics

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Exposing metrics to Prometheus

- Prometheus obtains metrics and their values by querying *exporters*

- An exporter serves metrics over HTTP, in plain text

- This is what the *node exporter* looks like:

  http://demo.robustperception.io:9100/metrics

- Prometheus itself exposes its own internal metrics, too:

  http://demo.robustperception.io:9090/metrics

- If you want to expose custom metrics to Prometheus:

  - serve a text page like these, and you're good to go

  - libraries are available in various languages to help with quantiles etc.

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## How Prometheus gets these metrics

- The *Prometheus server* will *scrape* URLs like these at regular intervals

  (by default: every minute; can be more/less frequent)

- The list of URLs to scrape (the *scrape targets*) is defined in configuration

.footnote[Worried about the overhead of parsing a text format?
<br/>
Check this [comparison](https://github.com/RichiH/OpenMetrics/blob/master/markdown/protobuf_vs_text.md) of the text format with the (now deprecated) protobuf format!]

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Defining scrape targets

This is maybe the simplest configuration file for Prometheus:
```yaml
scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
```

- In this configuration, Prometheus collects its own internal metrics

- A typical configuration file will have multiple `scrape_configs`

- In this configuration, the list of targets is fixed

- A typical configuration file will use dynamic service discovery

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Service discovery

This configuration file will leverage existing DNS `A` records:
```yaml
scrape_configs:
  - ...
  - job_name: 'node'
    dns_sd_configs:
      - names: ['api-backends.dc-paris-2.enix.io']
        type: 'A'
        port: 9100
```

- In this configuration, Prometheus resolves the provided name(s)

  (here, `api-backends.dc-paris-2.enix.io`)

- Each resulting IP address is added as a target on port 9100

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Dynamic service discovery

- In the DNS example, the names are re-resolved at regular intervals

- As DNS records are created/updated/removed, scrape targets change as well

- Existing data (previously collected metrics) is not deleted

- Other service discovery backends work in a similar fashion

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Other service discovery mechanisms

- Prometheus can connect to e.g. a cloud API to list instances

- Or to the Kubernetes API to list nodes, pods, services ...

- Or a service like Consul, Zookeeper, etcd, to list applications

- The resulting configurations files are *way more complex*

  (but don't worry, we won't need to write them ourselves)

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Time series database

- We could wonder, "why do we need a specialized database?"

- One metrics data point = metrics ID + timestamp + value

- With a classic SQL or noSQL data store, that's at least 160 bits of data + indexes

- Prometheus is way more efficient, without sacrificing performance

  (it will even be gentler on the I/O subsystem since it needs to write less)

- Would you like to know more? Check this video:

  [Storage in Prometheus 2.0](https://www.youtube.com/watch?v=C4YV-9CrawA) by [Goutham V](https://twitter.com/putadent) at DC17EU

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Checking if Prometheus is installed

- Before trying to install Prometheus, let's check if it's already there

.lab[

- Look for services with a label `app=prometheus` across all namespaces:
  ```bash
  kubectl get services --selector=app=prometheus --all-namespaces
  ```

]

If we see a `NodePort` service called `prometheus-server`, we're good!

(We can then skip to "Connecting to the Prometheus web UI".)

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Running Prometheus on our cluster

We need to:

- Run the Prometheus server in a pod

  (using e.g. a Deployment to ensure that it keeps running)

- Expose the Prometheus server web UI (e.g. with a NodePort)

- Run the *node exporter* on each node (with a Daemon Set)

- Set up a Service Account so that Prometheus can query the Kubernetes API

- Configure the Prometheus server

  (storing the configuration in a Config Map for easy updates)

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Helm charts to the rescue

- To make our lives easier, we are going to use a Helm chart

- The Helm chart will take care of all the steps explained above

  (including some extra features that we don't need, but won't hurt)

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Step 1: install Helm

- If we already installed Helm earlier, this command won't break anything

.lab[

- Install the Helm CLI:
  ```bash
  curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get-helm-3 \
  | bash
  ```

]

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Step 2: install Prometheus

- The following command, just like the previous ones, is idempotent

  (it won't error out if Prometheus is already installed)

.lab[

- Install Prometheus on our cluster:
  ```bash
    helm upgrade prometheus --install prometheus \
        --repo https://prometheus-community.github.io/helm-charts \
        --namespace prometheus --create-namespace \
        --set server.service.type=NodePort \
        --set server.service.nodePort=30090 \
        --set server.persistentVolume.enabled=false \
        --set alertmanager.enabled=false
  ```

]

Curious about all these flags? They're explained in the next slide.

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Explaining all the Helm flags

- `helm upgrade prometheus` → upgrade the release named `prometheus`
  <br/>
  (a "release" is an instance of an app deployed with Helm)

- `--install` → if it doesn't exist, install it (instead of upgrading)

- `prometheus` → use the chart named `prometheus`

- `--repo ...` → the chart is located on the following repository

- `--namespace prometheus` → put it in that specific namespace

- `--create-namespace` → create the namespace if it doesn't exist

- `--set ...` → here are some *values* to be used when rendering the chart's templates

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Values for the Prometheus chart

Helm *values* are parameters to customize our installation.

- `server.service.type=NodePort` → expose the Prometheus server with a NodePort

- `server.service.nodePort=30090` → set the specific NodePort number to use

- `server.persistentVolume.enabled=false` → do not use a PersistentVolumeClaim

- `alertmanager.enabled=false` → disable the alert manager entirely

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Connecting to the Prometheus web UI

- Let's connect to the web UI and see what we can do

.lab[

- Figure out the NodePort that was allocated to the Prometheus server:
  ```bash
  kubectl get svc --all-namespaces | grep prometheus-server
  ```

- With your browser, connect to that port


- It should be 30090 if we just installed Prometheus with the Helm chart!

]

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Querying some metrics

- This is easy... if you are familiar with PromQL

.lab[

- Click on "Graph", and in "expression", paste the following:
  ```
    sum by (instance) (
      irate(
        container_cpu_usage_seconds_total{
          pod=~"worker.*"
          }[5m]
      )
    )
  ```

]

- Click on the blue "Execute" button and on the "Graph" tab just below

- We see the cumulated CPU usage of worker pods for each node
  <br/>
  (if we just deployed Prometheus, there won't be much data to see, though)

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Getting started with PromQL

- We can't learn PromQL in just 5 minutes

- But we can cover the basics to get an idea of what is possible

  (and have some keywords and pointers)

- We are going to break down the query above

  (building it one step at a time)

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Graphing one metric across all tags

This query will show us CPU usage across all containers:
```
container_cpu_usage_seconds_total
```

- The suffix of the metrics name tells us:

  - the unit (seconds of CPU)

  - that it's the total used since the container creation

- Since it's a "total," it is an increasing quantity

  (we need to compute the derivative if we want e.g. CPU % over time)

- We see that the metrics retrieved have *tags* attached to them

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Selecting metrics with tags

This query will show us only metrics for worker containers:
```
container_cpu_usage_seconds_total{pod=~"worker.*"}
```

- The `=~` operator allows regex matching

- We select all the pods with a name starting with `worker`

  (it would be better to use labels to select pods; more on that later)

- The result is a smaller set of containers

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Transforming counters in rates

This query will show us CPU usage % instead of total seconds used:
```
100*irate(container_cpu_usage_seconds_total{pod=~"worker.*"}[5m])
```

- The [`irate`](https://prometheus.io/docs/prometheus/latest/querying/functions/#irate) operator computes the "per-second instant rate of increase"

  - `rate` is similar but allows decreasing counters and negative values

  - with `irate`, if a counter goes back to zero, we don't get a negative spike

- The `[5m]` tells how far to look back if there is a gap in the data

- And we multiply with `100*` to get CPU % usage

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Aggregation operators

This query sums the CPU usage per node:
```
sum by (instance) (
  irate(container_cpu_usage_seconds_total{pod=~"worker.*"}[5m])
)
```

- `instance` corresponds to the node on which the container is running

- `sum by (instance) (...)` computes the sum for each instance

- Note: all the other tags are collapsed

  (in other words, the resulting graph only shows the `instance` tag)

- PromQL supports many more [aggregation operators](https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## What kind of metrics can we collect?

- Node metrics (related to physical or virtual machines)

- Container metrics (resource usage per container)

- Databases, message queues, load balancers, ...

  (check out this [list of exporters](https://prometheus.io/docs/instrumenting/exporters/)!)

- Instrumentation (=deluxe `printf` for our code)

- Business metrics (customers served, revenue, ...)

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Node metrics

- CPU, RAM, disk usage on the whole node

- Total number of processes running, and their states

- Number of open files, sockets, and their states

- I/O activity (disk, network), per operation or volume

- Physical/hardware (when applicable): temperature, fan speed...

- ...and much more!

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Container metrics

- Similar to node metrics, but not totally identical

- RAM breakdown will be different

  - active vs inactive memory
  - some memory is *shared* between containers, and specially accounted for

- I/O activity is also harder to track

  - async writes can cause deferred "charges"
  - some page-ins are also shared between containers

For details about container metrics, see:
<br/>
http://jpetazzo.github.io/2013/10/08/docker-containers-metrics/

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Application metrics

- Arbitrary metrics related to your application and business

- System performance: request latency, error rate...

- Volume information: number of rows in database, message queue size...

- Business data: inventory, items sold, revenue...

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Detecting scrape targets

- Prometheus can leverage Kubernetes service discovery

  (with proper configuration)

- Services or pods can be annotated with:

  - `prometheus.io/scrape: true` to enable scraping
  - `prometheus.io/port: 9090` to indicate the port number
  - `prometheus.io/path: /metrics` to indicate the URI (`/metrics` by default)

- Prometheus will detect and scrape these (without needing a restart or reload)

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Querying labels

- What if we want to get metrics for containers belonging to a pod tagged `worker`?

- The cAdvisor exporter does not give us Kubernetes labels

- Kubernetes labels are exposed through another exporter

- We can see Kubernetes labels through metrics `kube_pod_labels`

  (each container appears as a time series with constant value of `1`)

- Prometheus *kind of* supports "joins" between time series

- But only if the names of the tags match exactly

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## What if the tags don't match?

- Older versions of cAdvisor exporter used tag `pod_name` for the name of a pod

- The Kubernetes service endpoints exporter uses tag `pod` instead

- See [this blog post](https://www.robustperception.io/exposing-the-software-version-to-prometheus) or [this other one](https://www.weave.works/blog/aggregating-pod-resource-cpu-memory-usage-arbitrary-labels-prometheus/) to see how to perform "joins"

- Note that Prometheus cannot "join" time series with different labels

  (see [Prometheus issue #2204](https://github.com/prometheus/prometheus/issues/2204) for the rationale)

- There is a workaround involving relabeling, but it's "not cheap"

  - see [this comment](https://github.com/prometheus/prometheus/issues/2204#issuecomment-261515520) for an overview

  - or [this blog post](https://5pi.de/2017/11/09/use-prometheus-vector-matching-to-get-kubernetes-utilization-across-any-pod-label/) for a complete description of the process

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## In practice

- Grafana is a beautiful (and useful) frontend to display all kinds of graphs

- Not everyone needs to know Prometheus, PromQL, Grafana, etc.

- But in a team, it is valuable to have at least one person who know them

- That person can set up queries and dashboards for the rest of the team

- It's a little bit like knowing how to optimize SQL queries, Dockerfiles...

  Don't panic if you don't know these tools!

  ...But make sure at least one person in your team is on it 💯

???

:EN:- Collecting metrics with Prometheus
:FR:- Collecter des métriques avec Prometheus

.debug[[k8s/prometheus.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/aerial-view-of-containers.jpg)]

---

name: toc-scaling-with-custom-metrics
class: title

 Scaling with custom metrics

.nav[
[Previous part](#toc-collecting-metrics-with-prometheus)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-dynamic-admission-control)
]

.debug[(automatically generated title slide)]

---
# Scaling with custom metrics

- The HorizontalPodAutoscaler v1 can only scale on Pod CPU usage

- Sometimes, we need to scale using other metrics:

  - memory

  - requests per second

  - latency

  - active sessions

  - items in a work queue

  - ...

- The HorizontalPodAutoscaler v2 can do it!

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Requirements

⚠️ Autoscaling on custom metrics is fairly complex!

- We need some metrics system

  (Prometheus is a popular option, but others are possible too)

- We need our metrics (latency, traffic...) to be fed in the system

  (with Prometheus, this might require a custom exporter)

- We need to expose these metrics to Kubernetes

  (Kubernetes doesn't "speak" the Prometheus API)

- Then we can set up autoscaling!

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## The plan

- We will deploy the DockerCoins demo app

  (one of its components has a bottleneck; its latency will increase under load)

- We will use Prometheus to collect and store metrics

- We will deploy a tiny HTTP latency monitor (a Prometheus *exporter*)

- We will deploy the "Prometheus adapter"

  (mapping Prometheus metrics to Kubernetes-compatible metrics)

- We will create an HorizontalPodAutoscaler 🎉

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Deploying DockerCoins

- That's the easy part!

.lab[

- Create a new namespace and switch to it:
  ```bash
  kubectl create namespace customscaling
  kns customscaling
  ```

- Deploy DockerCoins, and scale up the `worker` Deployment:
  ```bash
  kubectl apply -f ~/container.training/k8s/dockercoins.yaml
  kubectl scale deployment worker --replicas=10
  ```

]

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Current state of affairs

- The `rng` service is a bottleneck

  (it cannot handle more than 10 requests/second)

- With enough traffic, its latency increases

  (by about 100ms per `worker` Pod after the 3rd worker)

.lab[

- Check the `webui` port and open it in your browser:
  ```bash
  kubectl get service webui
  ```

- Check the `rng` ClusterIP and test it with e.g. `httping`:
  ```bash
  kubectl get service rng
  ```

]

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Measuring latency

- We will use a tiny custom Prometheus exporter, [httplat](https://github.com/denisgaudare/httplat)

- `httplat` exposes Prometheus metrics on port 9080 (by default)

- It monitors exactly one URL, that must be passed as a command-line argument

.lab[

- Deploy `httplat`:
  ```bash
  kubectl create deployment httplat --image=jpetazzo/httplat -- httplat http://rng/
  ```

- Expose it:
  ```bash
  kubectl expose deployment httplat --port=9080
  ```

]

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

class: extra-details

## Measuring latency in the real world

- We are using this tiny custom exporter for simplicity

- A more common method to collect latency is to use a service mesh

- A service mesh can usually collect latency for *all* services automatically

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Install Prometheus

- We will use the Prometheus community Helm chart

  (because we can configure it dynamically with annotations)

.lab[

- If it's not installed yet on the cluster, install Prometheus:
  ```bash
    helm upgrade --install prometheus prometheus \
         --repo https://prometheus-community.github.io/helm-charts \
         --namespace prometheus --create-namespace \
         --set server.service.type=NodePort \
         --set server.service.nodePort=30090 \
         --set server.persistentVolume.enabled=false \
         --set alertmanager.enabled=false
  ```

]

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Configure Prometheus

- We can use annotations to tell Prometheus to collect the metrics

.lab[

- Tell Prometheus to "scrape" our latency exporter:
  ```bash
    kubectl annotate service httplat \
            prometheus.io/scrape=true \
            prometheus.io/port=9080 \
            prometheus.io/path=/metrics
  ```

]

If you deployed Prometheus differently, you might have to configure it manually.

You'll need to instruct it to scrape http://httplat.customscaling.svc:9080/metrics.

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Make sure that metrics get collected

- Before moving on, confirm that Prometheus has our metrics

.lab[

- Connect to Prometheus

  (if you installed it like instructed above, it is exposed as a NodePort on port 30090)

- Check that `httplat` metrics are available

- You can try to graph the following PromQL expression:
  ```
  rate(httplat_latency_seconds_sum[2m])/rate(httplat_latency_seconds_count[2m])
  ```

]

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Troubleshooting

- Make sure that the exporter works:

  - get the ClusterIP of the exporter with `kubectl get svc httplat`

  - `curl http://<ClusterIP>:9080/metrics`

  - check that the result includes the `httplat` histogram

- Make sure that Prometheus is scraping the exporter:

  - go to `Status` / `Targets` in Prometheus

  - make sure that `httplat` shows up in there

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Creating the autoscaling policy

- We need custom YAML (we can't use the `kubectl autoscale` command)

- It must specify `scaleTargetRef`, the resource to scale

  - any resource with a `scale` sub-resource will do

  - this includes Deployment, ReplicaSet, StatefulSet...

- It must specify one or more `metrics` to look at

  - if multiple metrics are given, the autoscaler will "do the math" for each one

  - it will then keep the largest result

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Details about the `metrics` list

- Each item will look like this:
  ```yaml
    - type: <TYPE-OF-METRIC>
      <TYPE-OF-METRIC>:
        metric:
          name: <NAME-OF-METRIC>
          <...optional selector (mandatory for External metrics)...>
        target:
          type: <TYPE-OF-TARGET>
          <TYPE-OF-TARGET>: <VALUE>
        <describedObject field, for Object metrics>
  ```

`<TYPE-OF-METRIC>` can be `Resource`, `Pods`, `Object`, or `External`.

`<TYPE-OF-TARGET>` can be `Utilization`, `Value`, or `AverageValue`.

Let's explain the 4 different `<TYPE-OF-METRIC>` values!

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## `Resource`

Use "classic" metrics served by `metrics-server` (`cpu` and `memory`).

```yaml
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
```

Compute average *utilization* (usage/requests) across pods.

It's also possible to specify `Value` or `AverageValue` instead of `Utilization`.

(To scale according to "raw" CPU or memory usage.)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## `Pods`

Use custom metrics. These are still "per-Pod" metrics.

```yaml
  - type: Pods
    pods:
      metric:
        name: packets-per-second
      target:
        type: AverageValue
        averageValue: 1k
```

`type:` *must* be `AverageValue`.

(It cannot be `Utilization`, since these can't be used in Pod `requests`.)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## `Object`

Use custom metrics. These metrics are "linked" to any arbitrary resource.

(E.g. a Deployment, Service, Ingress, ...)

```yaml
  - type: Object
    object:
      metric:
        name: requests-per-second
      describedObject:
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        name: main-route
      target:
        type: AverageValue
        value: 100
```

`type:` can be `Value` or `AverageValue` (see next slide for details).

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## `Value` vs `AverageValue`

- `Value`

  - use the value as-is

  - useful to pace a client or producer

  - "target a specific total load on a specific endpoint or queue"

- `AverageValue`

  - divide the value by the number of pods

  - useful to scale a server or consumer

  - "scale our systems to meet a given SLA/SLO"

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## `External`

Use arbitrary metrics. The series to use is specified with a label selector.

```yaml
  - type: External
    external:
      metric:
        name: queue_messages_ready
        selector: "queue=worker_tasks"
      target:
        type: AverageValue
        averageValue: 30
```

The `selector` will be passed along when querying the metrics API.

Its meaninng is implementation-dependent.

It may or may not correspond to Kubernetes labels.

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## One more thing ...

- We can give a `behavior` set of options

- Indicates:

  - how much to scale up/down in a single step

  - a *stabilization window* to avoid hysteresis effects

- The default stabilization window is 15 seconds for `scaleUp`

  (we might want to change that!)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

Putting togeher [k8s/hpa-v2-pa-httplat.yaml](https://github.com/denisgaudare/container.training/tree/master/k8s/hpa-v2-pa-httplat.yaml):

.small[
```yaml
kind: HorizontalPodAutoscaler
apiVersion: autoscaling/v2beta2
metadata:
  name: rng
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: rng
  minReplicas: 1
  maxReplicas: 20
  behavior:
    scaleUp:
        stabilizationWindowSeconds: 60
    scaleDown:
        stabilizationWindowSeconds: 180
  metrics:
  - type: Object
    object:
      describedObject:
        apiVersion: v1
        kind: Service
        name: httplat
      metric:
        name: httplat_latency_seconds
      target:
        type: Value
        value: 0.1


```
]

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Creating the autoscaling policy

- We will register the policy

- Of course, it won't quite work yet (we're missing the *Prometheus adapter*)

.lab[

- Create the HorizontalPodAutoscaler:
  ```bash
  kubectl apply -f ~/container.training/k8s/hpa-v2-pa-httplat.yaml
  ```

- Check the logs of the `controller-manager`:
  ```bash
  stern --namespace=kube-system --tail=10 controller-manager
  ```

]

After a little while we should see messages like this:
```
no custom metrics API (custom.metrics.k8s.io) registered
```

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## `custom.metrics.k8s.io`

- The HorizontalPodAutoscaler will get the metrics *from the Kubernetes API itself*

- In our specific case, it will access a resource like this one:
  .small[
  ```
  /apis/custom.metrics.k8s.io/v1beta1/namespaces/customscaling/services/httplat/httplat_latency_seconds
  ```
  ]

- By default, the Kubernetes API server doesn't implement `custom.metrics.k8s.io`

  (we can have a look at `kubectl get apiservices`)

- We need to:

  - start an API service implementing this API group

  - register it with our API server

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## The Prometheus adapter

- The Prometheus adapter is an open source project:

  https://github.com/DirectXMan12/k8s-prometheus-adapter

- It's a Kubernetes API service implementing API group `custom.metrics.k8s.io`

- It maps the requests it receives to Prometheus metrics

- Exactly what we need!

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Deploying the Prometheus adapter

- There is ~~an app~~ a Helm chart for that

.lab[

- Install the Prometheus adapter:
  ```bash
    helm upgrade --install prometheus-adapter prometheus-adapter \
      --repo https://prometheus-community.github.io/helm-charts \
      --namespace=prometheus-adapter --create-namespace \
      --set prometheus.url=http://prometheus-server.prometheus.svc \
      --set prometheus.port=80
  ```

]

- It comes with some default mappings

- But we will need to add `httplat` to these mappings

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Configuring the Prometheus adapter

- The Prometheus adapter can be configured/customized through a ConfigMap

- We are going to edit that ConfigMap, then restart the adapter

- We need to add a rule that will say:

  - all the metrics series named `httplat_latency_seconds_sum` ...

  - ... belong to *Services* ...

  - ... the name of the Service and its Namespace are indicated by the `kubernetes_name` and `kubernetes_namespace` Prometheus tags respectively ...

  - ... and the exact value to use should be the following PromQL expression

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## The mapping rule

Here is the rule that we need to add to the configuration:

```yaml
    - seriesQuery: 'httplat_latency_seconds_sum{namespace!="",service!=""}'
      resources:
        overrides:
          namespace:
            resource: namespace
          service:
            resource: service
      name:
        matches: "httplat_latency_seconds_sum"
        as: "httplat_latency_seconds"
      metricsQuery: |
        rate(httplat_latency_seconds_sum{<<.LabelMatchers>>}[2m])/rate(httplat_latency_seconds_count{<<.LabelMatchers>>}[2m])
```

(I built it following the [walkthrough](https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config-walkthrough.md
) in the Prometheus adapter documentation.)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Editing the adapter's configuration

.lab[

- Edit the adapter's ConfigMap:
  ```bash
  kubectl edit configmap prometheus-adapter --namespace=prometheus-adapter
  ```

- Add the new rule in the `rules` section, at the end of the configuration file

- Save, quit

- Restart the Prometheus adapter:
  ```bash
  kubectl rollout restart deployment --namespace=prometheus-adapter prometheus-adapter
  ```

]

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Witness the marvel of custom autoscaling

(Sort of)

- After a short while, the `rng` Deployment will scale up

- It should scale up until the latency drops below 100ms

  (and continue to scale up a little bit more after that)

- Then, since the latency will be well below 100ms, it will scale down

- ... and back up again, etc.

(See pictures on next slides!)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

class: pic

![Latency over time](images/hpa-v2-pa-latency.png)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

class: pic

![Number of pods over time](images/hpa-v2-pa-pods.png)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## What's going on?

- The autoscaler's information is slightly out of date

  (not by much; probably between 1 and 2 minute)

- It's enough to cause the oscillations to happen

- One possible fix is to tell the autoscaler to wait a bit after each action

- It will reduce oscillations, but will also slow down its reaction time

  (and therefore, how fast it reacts to a peak of traffic)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## What's going on? Take 2

- As soon as the measured latency is *significantly* below our target (100ms) ...

  the autoscaler tries to scale down

- If the latency is measured at 20ms ...

  the autoscaler will try to *divide the number of pods by five!*

- One possible solution: apply a formula to the measured latency,
  so that values between e.g. 10 and 100ms get very close to 100ms.

- Another solution: instead of targetting for a specific latency,
  target a 95th percentile latency or something similar, using
  a more advanced PromQL expression (and leveraging the fact that
  we have histograms instead of raw values).

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Troubleshooting

Check that the adapter registered itself correctly:
```bash
kubectl get apiservices | grep metrics
```

Check that the adapter correctly serves metrics:
```bash
kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1
```

Check that our `httplat` metrics are available:
```bash
kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1\
/namespaces/customscaling/services/httplat/httplat_latency_seconds
```

Also check the logs of the `prometheus-adapter` and the `kube-controller-manager`.

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Useful links

- [Horizontal Pod Autoscaler walkthrough](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/) in the Kubernetes documentation

- [Autoscaling design proposal](https://github.com/kubernetes/community/tree/master/contributors/design-proposals/autoscaling)

- [Kubernetes custom metrics API alternative implementations](https://github.com/kubernetes/metrics/blob/master/IMPLEMENTATIONS.md)

- [Prometheus adapter configuration walkthrough](https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config-walkthrough.md)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

## Discussion

- This system works great if we have a single, centralized metrics system

  (and the corresponding "adapter" to expose these metrics through the Kubernetes API)

- If we have metrics in multiple places, we must aggregate them

  (good news: Prometheus has exporters for almost everything!)

- It is complex and has a steep learning curve

- Another approach is [KEDA](https://keda.sh/)

???

:EN:- Autoscaling with custom metrics
:FR:- Suivi de charge avancé (HPAv2)

.debug[[k8s/hpa-v2.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/hpa-v2.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/blue-containers.jpg)]

---

name: toc-dynamic-admission-control
class: title

 Dynamic Admission Control

.nav[
[Previous part](#toc-scaling-with-custom-metrics)
|
[Back to table of contents](#toc-part-6)
|
[Next part](#toc-policy-management-with-kyverno)
]

.debug[(automatically generated title slide)]

---
# Dynamic Admission Control

- This is one of the many ways to extend the Kubernetes API

- High level summary: dynamic admission control relies on webhooks that are ...

  - dynamic (can be added/removed on the fly)

  - running inside our outside the cluster

  - *validating* (yay/nay) or *mutating* (can change objects that are created/updated)

  - selective (can be configured to apply only to some kinds, some selectors...)

  - mandatory or optional (should it block operations when webhook is down?)

- Used for themselves (e.g. policy enforcement) or as part of operators

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Use cases

Some examples ...

- Stand-alone admission controllers

  *validating:* policy enforcement (e.g. quotas, naming conventions ...)

  *mutating:* inject or provide default values (e.g. pod presets)

- Admission controllers part of a greater system

  *validating:* advanced typing for operators

  *mutating:* inject sidecars for service meshes

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## You said *dynamic?*

- Some admission controllers are built in the API server

- They are enabled/disabled through Kubernetes API server configuration

  (e.g. `--enable-admission-plugins`/`--disable-admission-plugins` flags)

- Here, we're talking about *dynamic* admission controllers

- They can be added/remove while the API server is running

  (without touching the configuration files or even having access to them)

- This is done through two kinds of cluster-scope resources:

  ValidatingWebhookConfiguration and MutatingWebhookConfiguration

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## You said *webhooks?*

- A ValidatingWebhookConfiguration or MutatingWebhookConfiguration contains:

  - a resource filter
    <br/>
    (e.g. "all pods", "deployments in namespace xyz", "everything"...)

  - an operations filter
    <br/>
    (e.g. CREATE, UPDATE, DELETE)

  - the address of the webhook server

- Each time an operation matches the filters, it is sent to the webhook server

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## What gets sent exactly?

- The API server will `POST` a JSON object to the webhook

- That object will be a Kubernetes API message with `kind` `AdmissionReview`

- It will contain a `request` field, with, notably:

  - `request.uid` (to be used when replying)

  - `request.object` (the object created/deleted/changed)

  - `request.oldObject` (when an object is modified)

  - `request.userInfo` (who was making the request to the API in the first place)

(See [the documentation](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#request) for a detailed example showing more fields.)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## How should the webhook respond?

- By replying with another `AdmissionReview` in JSON

- It should have a `response` field, with, notably:

  - `response.uid` (matching the `request.uid`)

  - `response.allowed` (`true`/`false`)

  - `response.status.message` (optional string; useful when denying requests)

  - `response.patchType` (when a mutating webhook changes the object; e.g. `json`)

  - `response.patch` (the patch, encoded in base64)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## What if the webhook *does not* respond?

- If "something bad" happens, the API server follows the `failurePolicy` option

  - this is a per-webhook option (specified in the webhook configuration)

  - it can be `Fail` (the default) or `Ignore` ("allow all, unmodified")

- What's "something bad"?

  - webhook responds with something invalid

  - webhook takes more than 10 seconds to respond
    <br/>
    (this can be changed with `timeoutSeconds` field in the webhook config)

  - webhook is down or has invalid certificates
    <br/>
    (TLS! It's not just a good idea; for admission control, it's the law!)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## What did you say about TLS?

- The webhook configuration can indicate:

  - either `url` of the webhook server (has to begin with `https://`)

  - or `service.name` and `service.namespace` of a Service on the cluster

- In the latter case, the Service has to accept TLS connections on port 443

- It has to use a certificate with CN `<name>.<namespace>.svc`

  (**and** a `subjectAltName` extension with `DNS:<name>.<namespace>.svc`)

- The certificate needs to be valid (signed by a CA trusted by the API server)

  ... alternatively, we can pass a `caBundle` in the webhook configuration

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Webhook server inside or outside

- "Outside" webhook server is defined with `url` option

  - convenient for external webooks (e.g. tamper-resistent audit trail)

  - also great for initial development (e.g. with ngrok)

  - requires outbound connectivity (duh) and can become a SPOF

- "Inside" webhook server is defined with `service` option

  - convenient when the webhook needs to be deployed and managed on the cluster

  - also great for air gapped clusters

  - development can be harder (but tools like [Tilt](https://tilt.dev) can help)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Developing a simple admission webhook

- We're going to register a custom webhook!

- First, we'll just dump the `AdmissionRequest` object

  (using a little Node app)

- Then, we'll implement a strict policy on a specific label

  (using a little Flask app)

- Development will happen in local containers, plumbed with ngrok

- The we will deploy to the cluster 🔥

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Running the webhook locally

- We prepared a Docker Compose file to start the whole stack

  (the Node "echo" app, the Flask app, and one ngrok tunnel for each of them)

.lab[

- Go to the webhook directory:
  ```bash
  cd ~/container.training/webhooks/admission
  ```

- Start the webhook in Docker containers:
  ```bash
  docker-compose up
  ```

]

*Note the URL in `ngrok-echo_1` looking like `url=https://xxxx.ngrok.io`.*

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

class: extra-details

## What's ngrok?

- Ngrok provides secure tunnels to access local services

- Example: run `ngrok http 1234`

- `ngrok` will display a publicly-available URL (e.g. https://xxxxyyyyzzzz.ngrok.io)

- Connections to https://xxxxyyyyzzzz.ngrok.io will terminate at `localhost:1234`

- Basic product is free; extra features (vanity domains, end-to-end TLS...) for $$$

- Perfect to develop our webhook!

- Probably not for production, though

  (webhook requests and responses now pass through the ngrok platform)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Update the webhook configuration

- We have a webhook configuration in `k8s/webhook-configuration.yaml`

- We need to update the configuration with the correct `url`

.lab[

- Edit the webhook configuration manifest:
  ```bash
  vim k8s/webhook-configuration.yaml
  ```

- **Uncomment** the `url:` line

- **Update** the `.ngrok.io` URL with the URL shown by Compose

- Save and quit

]

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Register the webhook configuration

- Just after we register the webhook, it will be called for each matching request

  (CREATE and UPDATE on Pods in all namespaces)

- The `failurePolicy` is `Ignore`

  (so if the webhook server is down, we can still create pods)

.lab[

- Register the webhook:
  ```bash
  kubectl apply -f k8s/webhook-configuration.yaml
  ```

]

It is strongly recommended to tail the logs of the API server while doing that.

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Create a pod

- Let's create a pod and try to set a `color` label

.lab[

- Create a pod named `chroma`:
  ```bash
  kubectl run --restart=Never chroma --image=nginx
  ```

- Add a label `color` set to `pink`:
  ```bash
  kubectl label pod chroma color=pink
  ```

]

We should see the `AdmissionReview` objects in the Compose logs.

Note: the webhook doesn't do anything (other than printing the request payload).

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Use the "real" admission webhook

- We have a small Flask app implementing a particular policy on pod labels:

  - if a pod sets a label `color`, it must be `blue`, `green`, `red`

  - once that `color` label is set, it cannot be removed or changed

- That Flask app was started when we did `docker-compose up` earlier

- It is exposed through its own ngrok tunnel

- We are going to use that webhook instead of the other one

  (by changing only the `url` field in the ValidatingWebhookConfiguration)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Update the webhook configuration

.lab[

- First, check the ngrok URL of the tunnel for the Flask app:
  ```bash
  docker-compose logs ngrok-flask
  ```

- Then, edit the webhook configuration:
  ```bash
  kubectl edit validatingwebhookconfiguration admission.container.training
  ```
- Find the `url:` field with the `.ngrok.io` URL and update it

- Save and quit; the new configuration is applied immediately

]

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Verify the behavior of the webhook

- Try to create a few pods and/or change labels on existing pods

- What happens if we try to make changes to the earlier pod?

  (the one that has `label=pink`)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Deploying the webhook on the cluster

- Let's see what's needed to self-host the webhook server!

- The webhook needs to be reachable through a Service on our cluster

- The Service needs to accept TLS connections on port 443

- We need a proper TLS certificate:

  - with the right `CN` and `subjectAltName` (`<servicename>.<namespace>.svc`)

  - signed by a trusted CA

- We can either use a "real" CA, or use the `caBundle` option to specify the CA cert

  (the latter makes it easy to use self-signed certs)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## In practice

- We're going to generate a key pair and a self-signed certificate

- We will store them in a Secret

- We will run the webhook in a Deployment, exposed with a Service

- We will update the webhook configuration to use that Service

- The Service will be named `admission`, in Namespace `webhooks`

  (keep in mind that the ValidatingWebhookConfiguration itself is at cluster scope)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Let's get to work!

.lab[

- Make sure we're in the right directory:
  ```bash
  cd ~/container.training/webhooks/admission
  ```

- Create the namespace:
  ```bash
  kubectl create namespace webhooks
  ```

- Switch to the namespace:
  ```bash
  kubectl config set-context --current --namespace=webhooks
  ```

]

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Deploying the webhook

- *Normally,* we would author an image for this

- Since our webhook is just *one* Python source file ...

  ... we'll store it in a ConfigMap, and install dependencies on the fly

.lab[

- Load the webhook source in a ConfigMap:
  ```bash
  kubectl create configmap admission --from-file=flask/webhook.py
  ```

- Create the Deployment and Service:
  ```bash
  kubectl apply -f k8s/webhook-server.yaml
  ```

]

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Generating the key pair and certificate

- Let's call OpenSSL to the rescue!

  (of course, there are plenty others options; e.g. `cfssl`)

.lab[

- Generate a self-signed certificate:
  ```bash
    NAMESPACE=webhooks
    SERVICE=admission
    CN=$SERVICE.$NAMESPACE.svc
    openssl req -x509 -newkey rsa:4096 -nodes -keyout key.pem -out cert.pem \
        -days 30 -subj /CN=$CN -addext subjectAltName=DNS:$CN
  ```

- Load up the key and cert in a Secret:
  ```bash
  kubectl create secret tls admission --cert=cert.pem --key=key.pem
  ```

]

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Update the webhook configuration

- Let's reconfigure the webhook to use our Service instead of ngrok

.lab[

- Edit the webhook configuration manifest:
  ```bash
  vim k8s/webhook-configuration.yaml
  ```

- Comment out the `url:` line

- Uncomment the `service:` section

- Save, quit

- Update the webhook configuration:
  ```bash
  kubectl apply -f k8s/webhook-configuration.yaml
  ```

]

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Add our self-signed cert to the `caBundle`

- The API server won't accept our self-signed certificate

- We need to add it to the `caBundle` field in the webhook configuration

- The `caBundle` will be our `cert.pem` file, encoded in base64

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

Shell to the rescue!

.lab[

- Load up our cert and encode it in base64:
  ```bash
  CA=$(base64 -w0 < cert.pem)
  ```

- Define a patch operation to update the `caBundle`:
  ```bash
    PATCH='[{
        "op": "replace",
        "path": "/webhooks/0/clientConfig/caBundle",
        "value":"'$CA'"
    }]'
  ```

- Patch the webhook configuration:
  ```bash
    kubectl patch validatingwebhookconfiguration \
                  admission.webhook.container.training \
                  --type='json' -p="$PATCH"
  ```

]

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

## Try it out!

- Keep an eye on the API server logs

- Tail the logs of the pod running the webhook server

- Create a few pods; we should see requests in the webhook server logs

- Check that the label `color` is enforced correctly

  (it should only allow values of `red`, `green`, `blue`)

???

:EN:- Dynamic admission control with webhooks
:FR:- Contrôle d'admission dynamique (webhooks)

.debug[[k8s/admission.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/admission.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/chinook-helicopter-container.jpg)]

---

name: toc-policy-management-with-kyverno
class: title

 Policy Management with Kyverno

.nav[
[Previous part](#toc-dynamic-admission-control)
|
[Back to table of contents](#toc-part-6)
|
[Next part](#toc-stateful-sets)
]

.debug[(automatically generated title slide)]

---
# Policy Management with Kyverno

- The Kubernetes permission management system is very flexible ...

- ... But it can't express *everything!*

- Examples:

  - forbid using `:latest` image tag

  - enforce that each Deployment, Service, etc. has an `owner` label
    <br/>(except in e.g. `kube-system`)

  - enforce that each container has at least a `readinessProbe` healthcheck

- How can we address that, and express these more complex *policies?*

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Admission control

- The Kubernetes API server provides a generic mechanism called *admission control*

- Admission controllers will examine each write request, and can:

  - approve/deny it (for *validating* admission controllers)

  - additionally *update* the object (for *mutating* admission controllers)

- These admission controllers can be:

  - plug-ins built into the Kubernetes API server
    <br/>(selectively enabled/disabled by e.g. command-line flags)

  - webhooks registered dynamically with the Kubernetes API server

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## What's Kyverno?

- Policy management solution for Kubernetes

- Open source (https://github.com/kyverno/kyverno/)

- Compatible with all clusters

  (doesn't require to reconfigure the control plane, enable feature gates...)

- We don't endorse / support it in a particular way, but we think it's cool

- It's not the only solution!

  (see e.g. [Open Policy Agent](https://www.openpolicyagent.org/docs/v0.12.2/kubernetes-admission-control/))

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## What can Kyverno do?

- *Validate* resource manifests

  (accept/deny depending on whether they conform to our policies)

- *Mutate* resources when they get created or updated

  (to add/remove/change fields on the fly)

- *Generate* additional resources when a resource gets created

  (e.g. when namespace is created, automatically add quotas and limits)

- *Audit* existing resources

  (warn about resources that violate certain policies)

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## How does it do it?

- Kyverno is implemented as a *controller* or *operator*

- It typically runs as a Deployment on our cluster

- Policies are defined as *custom resource definitions*

- They are implemented with a set of *dynamic admission control webhooks*

--

🤔

--

- Let's unpack that!

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Custom resource definitions

- When we install Kyverno, it will register new resource types:

  - Policy and ClusterPolicy (per-namespace and cluster-scope policies)

  - PolicyReport and ClusterPolicyReport (used in audit mode)

  - GenerateRequest (used internally when generating resources asynchronously)

- We will be able to do e.g. `kubectl get clusterpolicyreports --all-namespaces`

  (to see policy violations across all namespaces)

- Policies will be defined in YAML and registered/updated with e.g. `kubectl apply`

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Dynamic admission control webhooks

- When we install Kyverno, it will register a few webhooks for its use

  (by creating ValidatingWebhookConfiguration and MutatingWebhookConfiguration resources)

- All subsequent resource modifications are submitted to these webhooks

  (creations, updates, deletions)

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Controller

- When we install Kyverno, it creates a Deployment (and therefore, a Pod)

- That Pod runs the server used by the webhooks

- It also runs a controller that will:

  - run checks in the background (and generate PolicyReport objects)

  - process GenerateRequest objects asynchronously

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Kyverno in action

- We're going to install Kyverno on our cluster

- Then, we will use it to implement a few policies

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Installing Kyverno

- Kyverno can be installed with a (big) YAML manifest

- ... or with Helm charts (which allows to customize a few things)

.lab[

- Install Kyverno:
  ```bash
  kubectl create -f https://raw.githubusercontent.com/kyverno/kyverno/release-1.5/definitions/release/install.yaml
  ```

]

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Kyverno policies in a nutshell

- Which resources does it *select?*

  - can specify resources to *match* and/or *exclude*

  - can specify *kinds* and/or *selector* and/or users/roles doing the action

- Which operation should be done?

  - validate, mutate, or generate

- For validation, whether it should *enforce* or *audit* failures

- Operation details (what exactly to validate, mutate, or generate)

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Painting pods

- As an example, we'll implement a policy regarding "Pod color"

- The color of a Pod is the value of the label `color`

- Example: `kubectl label pod hello color=yellow` to paint a Pod in yellow

- We want to implement the following policies:

  - color is optional (i.e. the label is not required)

  - if color is set, it *must* be `red`, `green`, or `blue`

  - once the color has been set, it cannot be changed

  - once the color has been set, it cannot be removed

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Immutable primary colors, take 1

- First, we will add a policy to block forbidden colors

  (i.e. only allow `red`, `green`, or `blue`)

- One possible approach:

  - *match* all pods that have a `color` label that is not `red`, `green`, or `blue`

  - *deny* these pods

- We could also *match* all pods, then *deny* with a condition

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

.small[
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: pod-color-policy-1
spec:
  validationFailureAction: enforce
  rules:
  - name: ensure-pod-color-is-valid
    match:
      resources:
        kinds:
        - Pod
        selector:
          matchExpressions:
          - key: color
            operator: Exists
          - key: color
            operator: NotIn
            values: [ red, green, blue ]
    validate:
      message: "If it exists, the label color must be red, green, or blue."
      deny: {}

```
]

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Testing without the policy

- First, let's create a pod with an "invalid" label

  (while we still can!)

- We will use this later

.lab[

- Create a pod:
  ```bash
  kubectl run test-color-0 --image=nginx
  ```

- Apply a color label:
  ```bash
  kubectl label pod test-color-0 color=purple
  ```

]

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Load and try the policy

.lab[

- Load the policy:
  ```bash
  kubectl apply -f ~/container.training/k8s/kyverno-pod-color-1.yaml
  ```

- Create a pod:
  ```bash
  kubectl run test-color-1 --image=nginx
  ```

- Try to apply a few color labels:
  ```bash
  kubectl label pod test-color-1 color=purple
  kubectl label pod test-color-1 color=red
  kubectl label pod test-color-1 color-
  ```

]

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Immutable primary colors, take 2

- Next rule: once a `color` label has been added, it cannot be changed

  (i.e. if `color=red`, we can't change it to `color=blue`)

- Our approach:

  - *match* all pods

  - add a *precondition* matching pods that have a `color` label
    <br/>
    (both in their "before" and "after" states)

  - *deny* these pods if their `color` label has changed

- Again, other approaches are possible!

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

.small[
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: pod-color-policy-2
spec:
  validationFailureAction: enforce
  background: false
  rules:
  - name: prevent-color-change
    match:
      resources:
        kinds:
        - Pod
    preconditions:
    - key: "{{ request.operation }}"
      operator: Equals
      value: UPDATE
    - key: "{{ request.oldObject.metadata.labels.color }}"
      operator: NotEquals
      value: ""
    - key: "{{ request.object.metadata.labels.color }}"
      operator: NotEquals
      value: ""
    validate:
      message: "Once label color has been added, it cannot be changed."
      deny:
        conditions:
        - key: "{{ request.object.metadata.labels.color }}"
          operator: NotEquals
          value: "{{ request.oldObject.metadata.labels.color }}"


```
]

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Invalid references

- We can access the `color` label through `{{ request.object.metadata.labels.color }}`

- If we reference a label (or any field) that doesn't exist, the policy fails

- Except in *preconditions*: it then evaluates to an empty string

- We use a *precondition* to makes sure the label exists in both "old" and "new" objects

- Then in the *deny* block we can compare the old and new values

  (and reject changes)

- "Old" and "new" versions of the pod can be referenced through

  `{{ request.oldObject }}` and `{{ request.object }}`

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Load and try the policy

.lab[

- Load the policy:
  ```bash
  kubectl apply -f ~/container.training/k8s/kyverno-pod-color-2.yaml
  ```

- Create a pod:
  ```bash
  kubectl run test-color-2 --image=nginx
  ```

- Try to apply a few color labels:
  ```bash
  kubectl label pod test-color-2 color=purple
  kubectl label pod test-color-2 color=red
  kubectl label pod test-color-2 color=blue --overwrite
  ```

]

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## `background`

- What is this `background: false` option, and why do we need it?

--

- Admission controllers are only invoked when we change an object

- Existing objects are not affected

  (e.g. if we have a pod with `color=pink` *before* installing our policy)

- Kyvero can also run checks in the background, and report violations

  (we'll see later how they are reported)

- `background: false` disables that

--

- Alright, but ... *why* do we need it?

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Accessing `AdmissionRequest` context

- In this specific policy, we want to prevent an *update*

  (as opposed to a mere *create* operation)

- We want to compare the *old* and *new* version

  (to check if a specific label was removed)

- The `AdmissionRequest` object has `object` and `oldObject` fields

  (the `AdmissionRequest` object is the thing that gets submitted to the webhook)

- We access the `AdmissionRequest` object through `{{ request }}`

--

- Alright, but ... what's the link with `background: false`?

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## `{{ request }}`

- The `{{ request }}` context is only available when there is an `AdmissionRequest`

- When a resource is "at rest", there is no `{{ request }}` (and no old/new)

- Therefore, a policy that uses `{{ request }}` cannot validate existing objects

  (it can only be used when an object is actually created/updated/deleted)

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Immutable primary colors, take 3

- Last rule: once a `color` label has been added, it cannot be removed

- Our approach is to match all pods that:

  - *had* a `color` label (in `request.oldObject`)

  - *don't have* a `color` label (in `request.Object`)

- And *deny* these pods

- Again, other approaches are possible!

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

.small[
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: pod-color-policy-3
spec:
  validationFailureAction: enforce
  background: false
  rules:
  - name: prevent-color-change
    match:
      resources:
        kinds:
        - Pod
    preconditions:
    - key: "{{ request.operation }}"
      operator: Equals
      value: UPDATE
    - key: "{{ request.oldObject.metadata.labels.color }}"
      operator: NotEquals
      value: ""
    - key: "{{ request.object.metadata.labels.color }}"
      operator: Equals
      value: ""
    validate:
      message: "Once label color has been added, it cannot be removed."
      deny:
        conditions:


```
]

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Load and try the policy

.lab[

- Load the policy:
  ```bash
  kubectl apply -f ~/container.training/k8s/kyverno-pod-color-3.yaml
  ```

- Create a pod:
  ```bash
  kubectl run test-color-3 --image=nginx
  ```

- Try to apply a few color labels:
  ```bash
  kubectl label pod test-color-3 color=purple
  kubectl label pod test-color-3 color=red
  kubectl label pod test-color-3 color-
  ```

]

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Background checks

- What about the `test-color-0` pod that we create initially?

  (remember: we did set `color=purple`)

- We can see the infringing Pod in a PolicyReport

.lab[

- Check that the pod still an "invalid" color:
  ```bash
  kubectl get pods -L color
  ```

- List PolicyReports:
  ```bash
  kubectl get policyreports
  kubectl get polr
  ```

]

(Sometimes it takes a little while for the infringement to show up, though.)

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Generating objects

- When we create a Namespace, we also want to automatically create:

  - a LimitRange (to set default CPU and RAM requests and limits)

  - a ResourceQuota (to limit the resources used by the namespace)

  - a NetworkPolicy (to isolate the namespace)

- We can do that with a Kyverno policy with a *generate* action

  (it is mutually exclusive with the *validate* action)

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Overview

- The *generate* action must specify:

  - the `kind` of resource to generate

  - the `name` of the resource to generate

  - its `namespace`, when applicable

  - *either* a `data` structure, to be used to populate the resource

  - *or* a `clone` reference, to copy an existing resource

Note: the `apiVersion` field appears to be optional.

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## In practice

- We will use the policy [k8s/kyverno-namespace-setup.yaml](https://github.com/denisgaudare/container.training/tree/master/k8s/kyverno-namespace-setup.yaml)

- We need to generate 3 resources, so we have 3 rules in the policy

- Excerpt:
  ```yaml
      generate: 
      kind: LimitRange
      name: default-limitrange
      namespace: "{{request.object.metadata.name}}" 
      data:
        spec:
          limits:
  ```

- Note that we have to specify the `namespace`

  (and we infer it from the name of the resource being created, i.e. the Namespace)

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Lifecycle

- After generated objects have been created, we can change them

  (Kyverno won't update them)

- Except if we use `clone` together with the `synchronize` flag

  (in that case, Kyverno will watch the cloned resource)

- This is convenient for e.g. ConfigMaps shared between Namespaces

- Objects are generated only at *creation* (not when updating an old object)

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Asynchronous creation

- Kyverno creates resources asynchronously

  (by creating a GenerateRequest resource first)

- This is useful when the resource cannot be created

  (because of permissions or dependency issues)

- Kyverno will periodically loop through the pending GenerateRequests

- Once the ressource is created, the GenerateRequest is marked as Completed

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Footprint

- 7 CRDs

- 5 webhooks

- 2 Services, 1 Deployment, 2 ConfigMaps

- Internal resources (GenerateRequest) "parked" in a Namespace

- Kyverno packs a lot of features in a small footprint

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Strengths

- Kyverno is very easy to install

  (it's harder to get easier than one `kubectl apply -f`)

- The setup of the webhooks is fully automated

  (including certificate generation)

- It offers both namespaced and cluster-scope policies

- The policy language leverages existing constructs

  (e.g. `matchExpressions`)

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

## Caveats

- The `{{ request }}` context is powerful, but difficult to validate

  (Kyverno can't know ahead of time how it will be populated)

- Advanced policies (with conditionals) have unique, exotic syntax:
  ```yaml
      spec:
	    =(volumes):
	      =(hostPath):
	        path: "!/var/run/docker.sock"
  ```

- Writing and validating policies can be difficult

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

class: extra-details

## Pods created by controllers

- When e.g. a ReplicaSet or DaemonSet creates a pod, it "owns" it

  (the ReplicaSet or DaemonSet is listed in the Pod's `.metadata.ownerReferences`)

- Kyverno treats these Pods differently

- If my understanding of the code is correct (big *if*):

  - it skips validation for "owned" Pods

  - instead, it validates their controllers

  - this way, Kyverno can report errors on the controller instead of the pod

- This can be a bit confusing when testing policies on such pods!

???

:EN:- Policy Management with Kyverno
:FR:- Gestion de *policies* avec Kyverno

.debug[[k8s/kyverno.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/kyverno.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/container-cranes.jpg)]

---

name: toc-stateful-sets
class: title

 Stateful sets

.nav[
[Previous part](#toc-policy-management-with-kyverno)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-local-persistent-volumes)
]

.debug[(automatically generated title slide)]

---
# Stateful sets

- Stateful sets are a type of resource in the Kubernetes API

  (like pods, deployments, services...)

- They offer mechanisms to deploy scaled stateful applications

- At a first glance, they look like Deployments:

  - a stateful set defines a pod spec and a number of replicas *R*

  - it will make sure that *R* copies of the pod are running

  - that number can be changed while the stateful set is running

  - updating the pod spec will cause a rolling update to happen

- But they also have some significant differences

.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Stateful sets unique features

- Pods in a stateful set are numbered (from 0 to *R-1*) and ordered

- They are started and updated in order (from 0 to *R-1*)

- A pod is started (or updated) only when the previous one is ready

- They are stopped in reverse order (from *R-1* to 0)

- Each pod knows its identity (i.e. which number it is in the set)

- Each pod can discover the IP address of the others easily

- The pods can persist data on attached volumes

🤔 Wait a minute ... Can't we already attach volumes to pods and deployments?

.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Revisiting volumes

- [Volumes](https://kubernetes.io/docs/concepts/storage/volumes/) are used for many purposes:

  - sharing data between containers in a pod

  - exposing configuration information and secrets to containers

  - accessing storage systems

- Let's see examples of the latter usage

.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Volumes types

- There are many [types of volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes) available:

  - public cloud storage (GCEPersistentDisk, AWSElasticBlockStore, AzureDisk...)

  - private cloud storage (Cinder, VsphereVolume...)

  - traditional storage systems (NFS, iSCSI, FC...)

  - distributed storage (Ceph, Glusterfs, Portworx...)

- Using a persistent volume requires:

  - creating the volume out-of-band (outside of the Kubernetes API)

  - referencing the volume in the pod description, with all its parameters

.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Using a cloud volume

Here is a pod definition using an AWS EBS volume (that has to be created first):

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-using-my-ebs-volume
spec:
  containers:
  - image: ...
    name: container-using-my-ebs-volume
    volumeMounts:
    - mountPath: /my-ebs
      name: my-ebs-volume
  volumes:
  - name: my-ebs-volume
    awsElasticBlockStore:
      volumeID: vol-049df61146c4d7901
      fsType: ext4
```

.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Using an NFS volume

Here is another example using a volume on an NFS server:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-using-my-nfs-volume
spec:
  containers:
  - image: ...
    name: container-using-my-nfs-volume
    volumeMounts:
    - mountPath: /my-nfs
      name: my-nfs-volume
  volumes:
  - name: my-nfs-volume
    nfs:
      server: 192.168.0.55
      path: "/exports/assets"
```

.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Shortcomings of volumes

- Their lifecycle (creation, deletion...) is managed outside of the Kubernetes API

  (we can't just use `kubectl apply/create/delete/...` to manage them)

- If a Deployment uses a volume, all replicas end up using the same volume

- That volume must then support concurrent access

  - some volumes do (e.g. NFS servers support multiple read/write access)

  - some volumes support concurrent reads

  - some volumes support concurrent access for colocated pods

- What we really need is a way for each replica to have its own volume

.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Individual volumes

- The Pods of a Stateful set can have individual volumes

  (i.e. in a Stateful set with 3 replicas, there will be 3 volumes)

- These volumes can be either:

  - allocated from a pool of pre-existing volumes (disks, partitions ...)

  - created dynamically using a storage system

- This introduces a bunch of new Kubernetes resource types:

  Persistent Volumes, Persistent Volume Claims, Storage Classes

  (and also `volumeClaimTemplates`, that appear within Stateful Set manifests!)

.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Stateful set recap

- A Stateful sets manages a number of identical pods

  (like a Deployment)

- These pods are numbered, and started/upgraded/stopped in a specific order

- These pods are aware of their number

  (e.g., #0 can decide to be the primary, and #1 can be secondary)

- These pods can find the IP addresses of the other pods in the set

  (through a *headless service*)

- These pods can each have their own persistent storage

.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Obtaining per-pod storage

- Stateful Sets can have *persistent volume claim templates*

  (declared in `spec.volumeClaimTemplates` in the Stateful set manifest)

- A claim template will create one Persistent Volume Claim per pod

  (the PVC will be named `<claim-name>.<stateful-set-name>.<pod-index>`)

- Persistent Volume Claims are matched 1-to-1 with Persistent Volumes

- Persistent Volume provisioning can be done:

  - automatically (by leveraging *dynamic provisioning* with a Storage Class)

  - manually (human operator creates the volumes ahead of time, or when needed)

???

:EN:- Deploying apps with Stateful Sets
:EN:- Understanding Persistent Volume Claims and Storage Classes
:FR:- Déployer une application avec un *Stateful Set*
:FR:- Comprendre les *Persistent Volume Claims* et *Storage Classes*


.debug[[k8s/statefulsets.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/container-housing.jpg)]

---

name: toc-local-persistent-volumes
class: title

 Local Persistent Volumes

.nav[
[Previous part](#toc-stateful-sets)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-an-elasticsearch-operator)
]

.debug[(automatically generated title slide)]

---
# Local Persistent Volumes

- We want to run that Consul cluster *and* actually persist data

- But we don't have a distributed storage system

- We are going to use local volumes instead

  (similar conceptually to `hostPath` volumes)

- We can use local volumes without installing extra plugins

- However, they are tied to a node

- If that node goes down, the volume becomes unavailable

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## With or without dynamic provisioning

- We will deploy a Consul cluster *with* persistence

- That cluster's StatefulSet will create PVCs

- These PVCs will remain unbound¹, until we will create local volumes manually

  (we will basically do the job of the dynamic provisioner)

- Then, we will see how to automate that with a dynamic provisioner

.footnote[¹Unbound = without an associated Persistent Volume.]

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## If we have a dynamic provisioner ...

- The labs in this section assume that we *do not* have a dynamic provisioner

- If we do have one, we need to disable it

.exercise[

- Check if we have a dynamic provisioner:
  ```bash
  kubectl get storageclass
  ```

- If the output contains a line with `(default)`, run this command:
  ```bash
  kubectl annotate sc storageclass.kubernetes.io/is-default-class- --all
  ```

- Check again that it is no longer marked as `(default)`

]

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Deploying Consul

- Let's use a new manifest for our Consul cluster

- The only differences between that file and the previous one are:

  - `volumeClaimTemplate` defined in the Stateful Set spec

  - the corresponding `volumeMounts` in the Pod spec

.exercise[

- Apply the persistent Consul YAML file:
  ```bash
  kubectl apply -f ~/container.training/k8s/consul-3.yaml
  ```

]

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Observing the situation

- Let's look at Persistent Volume Claims and Pods

.exercise[

- Check that we now have an unbound Persistent Volume Claim:
  ```bash
  kubectl get pvc
  ```

- We don't have any Persistent Volume:
  ```bash
  kubectl get pv
  ```

- The Pod `consul-0` is not scheduled yet:
  ```bash
  kubectl get pods -o wide
  ```

]

*Hint: leave these commands running with `-w` in different windows.*

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Explanations

- In a Stateful Set, the Pods are started one by one

- `consul-1` won't be created until `consul-0` is running

- `consul-0` has a dependency on an unbound Persistent Volume Claim

- The scheduler won't schedule the Pod until the PVC is bound

  (because the PVC might be bound to a volume that is only available on a subset of nodes; for instance EBS are tied to an availability zone)

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Creating Persistent Volumes

- Let's create 3 local directories (`/mnt/consul`) on node2, node3, node4

- Then create 3 Persistent Volumes corresponding to these directories

.exercise[

- Create the local directories:
  ```bash
    for NODE in node2 node3 node4; do
      ssh $NODE sudo mkdir -p /mnt/consul
    done
  ```

- Create the PV objects:
  ```bash
  kubectl apply -f ~/container.training/k8s/volumes-for-consul.yaml
  ```

]

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Check our Consul cluster

- The PVs that we created will be automatically matched with the PVCs

- Once a PVC is bound, its pod can start normally

- Once the pod `consul-0` has started, `consul-1` can be created, etc.

- Eventually, our Consul cluster is up, and backend by "persistent" volumes

.exercise[

- Check that our Consul clusters has 3 members indeed:
  ```bash
  kubectl exec consul-0 -- consul members
  ```

]

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Devil is in the details (1/2)

- The size of the Persistent Volumes is bogus

  (it is used when matching PVs and PVCs together, but there is no actual quota or limit)

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Devil is in the details (2/2)

- This specific example worked because we had exactly 1 free PV per node:

  - if we had created multiple PVs per node ...

  - we could have ended with two PVCs bound to PVs on the same node ...

  - which would have required two pods to be on the same node ...

  - which is forbidden by the anti-affinity constraints in the StatefulSet

- To avoid that, we need to associated the PVs with a Storage Class that has:
  ```yaml
  volumeBindingMode: WaitForFirstConsumer
  ```
  (this means that a PVC will be bound to a PV only after being used by a Pod)

- See [this blog post](https://kubernetes.io/blog/2018/04/13/local-persistent-volumes-beta/) for more details

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Bulk provisioning

- It's not practical to manually create directories and PVs for each app

- We *could* pre-provision a number of PVs across our fleet

- We could even automate that with a Daemon Set:

  - creating a number of directories on each node

  - creating the corresponding PV objects

- We also need to recycle volumes

- ... This can quickly get out of hand

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Dynamic provisioning

- We could also write our own provisioner, which would:

  - watch the PVCs across all namespaces

  - when a PVC is created, create a corresponding PV on a node

- Or we could use one of the dynamic provisioners for local persistent volumes

  (for instance the [Rancher local path provisioner](https://github.com/rancher/local-path-provisioner))

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

## Strategies for local persistent volumes

- Remember, when a node goes down, the volumes on that node become unavailable

- High availability will require another layer of replication

  (like what we've just seen with Consul; or primary/secondary; etc)

- Pre-provisioning PVs makes sense for machines with local storage

  (e.g. cloud instance storage; or storage directly attached to a physical machine)

- Dynamic provisioning makes sense for large number of applications

  (when we can't or won't dedicate a whole disk to a volume)

- It's possible to mix both (using distinct Storage Classes)

???

:EN:- Static vs dynamic volume provisioning
:EN:- Example: local persistent volume provisioner
:FR:- Création statique ou dynamique de volumes
:FR:- Exemple : création de volumes locaux

.debug[[k8s/local-persistent-volumes.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/local-persistent-volumes.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/containers-by-the-water.jpg)]

---

name: toc-an-elasticsearch-operator
class: title

 An ElasticSearch Operator

.nav[
[Previous part](#toc-local-persistent-volumes)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-openebs-)
]

.debug[(automatically generated title slide)]

---
# An ElasticSearch Operator

- We will install [Elastic Cloud on Kubernetes](https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-quickstart.html), an ElasticSearch operator

- This operator requires PersistentVolumes

- We will install Rancher's [local path storage provisioner](https://github.com/rancher/local-path-provisioner) to automatically create these

- Then, we will create an ElasticSearch resource

- The operator will detect that resource and provision the cluster

- We will integrate that ElasticSearch cluster with other resources

  (Kibana, Filebeat, Cerebro ...)

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Installing a Persistent Volume provisioner

(This step can be skipped if you already have a dynamic volume provisioner.)

- This provisioner creates Persistent Volumes backed by `hostPath`

  (local directories on our nodes)

- It doesn't require anything special ...

- ... But losing a node = losing the volumes on that node!

.lab[

- Install the local path storage provisioner:
  ```bash
  kubectl apply -f ~/container.training/k8s/local-path-storage.yaml
  ```

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Making sure we have a default StorageClass

- The ElasticSearch operator will create StatefulSets

- These StatefulSets will instantiate PersistentVolumeClaims

- These PVCs need to be explicitly associated with a StorageClass

- Or we need to tag a StorageClass to be used as the default one

.lab[

- List StorageClasses:
  ```bash
  kubectl get storageclasses
  ```

]

We should see the `local-path` StorageClass.

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Setting a default StorageClass

- This is done by adding an annotation to the StorageClass:

  `storageclass.kubernetes.io/is-default-class: true`

.lab[

- Tag the StorageClass so that it's the default one:
  ```bash
  kubectl annotate storageclass local-path \
            storageclass.kubernetes.io/is-default-class=true
  ```

- Check the result:
  ```bash
  kubectl get storageclasses
  ```

]

Now, the StorageClass should have `(default)` next to its name.

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Install the ElasticSearch operator

- The operator provides:

  - a few CustomResourceDefinitions
  - a Namespace for its other resources
  - a ValidatingWebhookConfiguration for type checking
  - a StatefulSet for its controller and webhook code
  - a ServiceAccount, ClusterRole, ClusterRoleBinding for permissions

- All these resources are grouped in a convenient YAML file

.lab[

- Install the operator:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-operator.yaml
  ```

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Check our new custom resources

- Let's see which CRDs were created

.lab[

- List all CRDs:
  ```bash
  kubectl get crds
  ```

]

This operator supports ElasticSearch, but also Kibana and APM. Cool!

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Create the `eck-demo` namespace

- For clarity, we will create everything in a new namespace, `eck-demo`

- This namespace is hard-coded in the YAML files that we are going to use

- We need to create that namespace

.lab[

- Create the `eck-demo` namespace:
  ```bash
  kubectl create namespace eck-demo
  ```

- Switch to that namespace:
  ```bash
  kns eck-demo
  ```

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

class: extra-details

## Can we use a different namespace?

Yes, but then we need to update all the YAML manifests that we
are going to apply in the next slides.

The `eck-demo` namespace is hard-coded in these YAML manifests.

Why?

Because when defining a ClusterRoleBinding that references a
ServiceAccount, we have to indicate in which namespace the
ServiceAccount is located.

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Create an ElasticSearch resource

- We can now create a resource with `kind: ElasticSearch`

- The YAML for that resource will specify all the desired parameters:

  - how many nodes we want
  - image to use
  - add-ons (kibana, cerebro, ...)
  - whether to use TLS or not
  - etc.

.lab[

- Create our ElasticSearch cluster:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-elasticsearch.yaml
  ```

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Operator in action

- Over the next minutes, the operator will create our ES cluster

- It will report our cluster status through the CRD

.lab[

- Check the logs of the operator:
  ```bash
  stern --namespace=elastic-system operator
  ```

<!--
```wait elastic-operator-0```
```tmux split-pane -v```
--->

- Watch the status of the cluster through the CRD:
  ```bash
  kubectl get es -w
  ```

<!--
```longwait green```
```key ^C```
```key ^D```
```key ^C```
-->

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Connecting to our cluster

- It's not easy to use the ElasticSearch API from the shell

- But let's check at least if ElasticSearch is up!

.lab[

- Get the ClusterIP of our ES instance:
  ```bash
  kubectl get services
  ```

- Issue a request with `curl`:
  ```bash
  curl http://`CLUSTERIP`:9200
  ```

]

We get an authentication error. Our cluster is protected!

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Obtaining the credentials

- The operator creates a user named `elastic`

- It generates a random password and stores it in a Secret

.lab[

- Extract the password:
  ```bash
    kubectl get secret demo-es-elastic-user \
            -o go-template="{{ .data.elastic | base64decode }} "
  ```

- Use it to connect to the API:
  ```bash
  curl -u elastic:`PASSWORD` http://`CLUSTERIP`:9200
  ```

]

We should see a JSON payload with the `"You Know, for Search"` tagline.

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Sending data to the cluster

- Let's send some data to our brand new ElasticSearch cluster!

- We'll deploy a filebeat DaemonSet to collect node logs

.lab[

- Deploy filebeat:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-filebeat.yaml
  ```

- Wait until some pods are up:
  ```bash
  watch kubectl get pods -l k8s-app=filebeat
  ```

<!--
```wait Running```
```key ^C```
-->

- Check that a filebeat index was created:
  ```bash
  curl -u elastic:`PASSWORD` http://`CLUSTERIP`:9200/_cat/indices
  ```

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Deploying an instance of Kibana

- Kibana can visualize the logs injected by filebeat

- The ECK operator can also manage Kibana

- Let's give it a try!

.lab[

- Deploy a Kibana instance:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-kibana.yaml
  ```

- Wait for it to be ready:
  ```bash
  kubectl get kibana -w
  ```

<!--
```longwait green```
```key ^C```
-->

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Connecting to Kibana

- Kibana is automatically set up to conect to ElasticSearch

  (this is arranged by the YAML that we're using)

- However, it will ask for authentication

- It's using the same user/password as ElasticSearch

.lab[

- Get the NodePort allocated to Kibana:
  ```bash
  kubectl get services
  ```

- Connect to it with a web browser

- Use the same user/password as before

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Setting up Kibana

After the Kibana UI loads, we need to click around a bit

.lab[

- Pick "explore on my own"

- Click on Use Elasticsearch data / Connect to your Elasticsearch index"

- Enter `filebeat-*` for the index pattern and click "Next step"

- Select `@timestamp` as time filter field name

- Click on "discover" (the small icon looking like a compass on the left bar)

- Play around!

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Scaling up the cluster

- At this point, we have only one node

- We are going to scale up

- But first, we'll deploy Cerebro, an UI for ElasticSearch

- This will let us see the state of the cluster, how indexes are sharded, etc.

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Deploying Cerebro

- Cerebro is stateless, so it's fairly easy to deploy

  (one Deployment + one Service)

- However, it needs the address and credentials for ElasticSearch

- We prepared yet another manifest for that!

.lab[

- Deploy Cerebro:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-cerebro.yaml
  ```

- Lookup the NodePort number and connect to it:
  ```bash
  kubectl get services
  ```

]

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Scaling up the cluster

- We can see on Cerebro that the cluster is "yellow"

  (because our index is not replicated)

- Let's change that!

.lab[

- Edit the ElasticSearch cluster manifest:
  ```bash
  kubectl edit es demo
  ```

- Find the field `count: 1` and change it to 3

- Save and quit

<!--
```wait Please edit```
```keys /count:```
```key ^J```
```keys $r3:x```
```key ^J```
-->

]

???

:EN:- Deploying ElasticSearch with ECK
:FR:- Déployer ElasticSearch avec ECK

.debug[[k8s/eck.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/eck.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://gallant-turing-d0d520.netlify.com/containers/distillery-containers.jpg)]

---

name: toc-openebs-
class: title

 OpenEBS 

.nav[
[Previous part](#toc-an-elasticsearch-operator)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-)
]

.debug[(automatically generated title slide)]

---
# OpenEBS 

 - [OpenEBS] is a popular open-source storage solution for Kubernetes

 - Uses the concept of "Container Attached Storage"

   (1 volume = 1 dedicated controller pod + a set of replica pods)

 - Supports a wide range of storage engines:

   - LocalPV: local volumes (hostpath or device), no replication

   - Jiva: for lighter workloads with basic cloning/snapshotting

   - cStor: more powerful engine that also supports resizing, RAID, disk pools ...

   - [Mayastor]: newer, even more powerful engine with NVMe and vhost-user support

[OpenEBS]: https://openebs.io/

[Mayastor]: https://github.com/openebs/MayaStor#mayastor

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

class: extra-details

## What are all these storage engines?

- LocalPV is great if we want good performance, no replication, easy setup

  (it is similar to the Rancher local path provisioner)

- Jiva is great if we want replication and easy setup

  (data is stored in containers' filesystems)

- cStor is more powerful and flexible, but requires more extensive setup

- Mayastor is designed to achieve extreme performance levels

  (with the right hardware and disks)

- The OpenEBS documentation has a [good comparison of engines] to help us pick

[good comparison of engines]: https://docs.openebs.io/docs/next/casengines.html#cstor-vs-jiva-vs-localpv-features-comparison

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Installing OpenEBS with Helm

- The OpenEBS control plane can be installed with Helm

- It will run as a set of containers on Kubernetes worker nodes

.lab[

  - Install OpenEBS:
  ```bash  
    helm upgrade --install openebs openebs \
         --repo https://openebs.github.io/charts \
         --namespace openebs --create-namespace \
         --version 2.12.9
  ```
]

⚠️ We stick to OpenEBS 2.x because 3.x requires additional configuration.

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Checking what was installed

- Wait a little bit ...

.lab[

- Look at the pods in the `openebs` namespace:
  ```bash  
      kubectl get pods --namespace openebs
  ```

- And the StorageClasses that were created:
  ```bash  
      kubectl get sc
  ```

]

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## The default StorageClasses

- OpenEBS typically creates three default StorageClasses

- `openebs-jiva-default` provisions 3 replicated Jiva pods per volume

  - data is stored in `/openebs` in the replica pods
  - `/openebs` is a localpath volume mapped to `/var/openebs/pvc-...` on the node

- `openebs-hostpath` uses LocalPV with local directories

  - volumes are hostpath volumes created in `/var/openebs/local` on each node

- `openebs-device` uses LocalPV with local block devices

  - requires available disks and/or a bit of extra configuration
  - the default configuration filters out loop, LVM, MD devices

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## When do we need custom StorageClasses?

- To store LocalPV hostpath volumes on a different path on the host

- To change the number of replicated Jiva pods

- To use a different Jiva pool

  (i.e. a different path on the host to store the Jiva volumes)

- To create a cStor pool

- ...

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

class: extra-details

## Defining a custom StorageClass

Example for a LocalPV hostpath class using an extra mount on `/mnt/vol001`:

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: localpv-hostpath-mntvol001
  annotations:
    openebs.io/cas-type: local
    cas.openebs.io/config: |
      - name: BasePath
        value: "/mnt/vol001"
      - name: StorageType
        value: "hostpath"
provisioner: openebs.io/local
```

- `provisioner` needs to be set accordingly
- Storage engine is chosen by specifying the annotation `openebs.io/cas-type`
- Storage engine configuration is set with the annotation `cas.openebs.io/config` 

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Checking the default hostpath StorageClass

- Let's inspect the StorageClass that OpenEBS created for us

.lab[

- Let's look at the OpenEBS LocalPV hostpath StorageClass:
  ```bash
  kubectl get storageclass openebs-hostpath -o yaml
  ``` 
]

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Create a host path PVC

- Let's create a Persistent Volume Claim using an explicit StorageClass

.lab[

```bash
kubectl apply -f - <<EOF
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: local-hostpath-pvc
spec:
  storageClassName: openebs-hostpath
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1G
EOF
```

]

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Making sure that a PV was created for our PVC

- Normally, the `openebs-hostpath` StorageClass created a PV for our PVC

.lab[

- Look at the PV and PVC:
  ```bash
  kubectl get pv,pvc
  ```

]

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Create a Pod to consume the PV

.lab[

- Create a Pod using that PVC:
  ```bash
  kubectl apply -f ~/container.training/k8s/openebs-pod.yaml
  ```

- Here are the sections that declare and use the volume:
  ```yaml
    volumes:
    - name: my-storage
      persistentVolumeClaim:
        claimName: local-hostpath-pvc
    containers:
    ...  
      volumeMounts:
      - mountPath: /mnt/storage
        name: my-storage
  ```

]

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Verify that data is written on the node

- Let's find the file written by the Pod on the node where the Pod is running

.lab[

- Get the worker node where the pod is located
  ```bash
  kubectl get pod openebs-local-hostpath-pod -ojsonpath={.spec.nodeName}
  ```

- SSH into the node

- Check the volume content
  ```bash
  sudo tail /var/openebs/local/pvc-*/greet.txt
  ```

]

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Heads up!

- The following labs and exercises will use the Jiva storage class

- This storage class creates 3 replicas by default

- It uses *anti-affinity* placement constraits to put these replicas on different nodes

- **This requires a cluster with multiple nodes!**

- It also requires the iSCSI client (aka *initiator*) to be installed on the nodes

- On many platforms, the iSCSI client is preinstalled and will start automatically

- If it doesn't, you might want to check [this documentation page] for details

[this documentation page]: https://docs.openebs.io/docs/next/prerequisites.html

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## The default StorageClass

- The PVC that we defined earlier specified an explicit StorageClass

- We can also set a default StorageClass

- It will then be used for all PVC that *don't* specify and explicit StorageClass

- This is done with the annotation `storageclass.kubernetes.io/is-default-class`

.lab[

- Check if we have a default StorageClass:
  ```bash
  kubectl get storageclasses
  ```
]

- The default StorageClass (if there is one) is shown with `(default)`

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Setting a default StorageClass

- Let's set the default StorageClass to use `openebs-jiva-default`

.lab[

- Remove the annotation (just in case we already have a default class):
  ```bash
  kubectl annotate storageclass storageclass.kubernetes.io/is-default-class- --all
  ```

- Annotate the Jiva StorageClass:
  ```bash
  kubectl annotate storageclasses \
      openebs-jiva-default storageclass.kubernetes.io/is-default-class=true
  ```

- Check the result:
  ```bash
  kuectl get storageclasses
  ```

]

.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## We're ready now!

- We have a StorageClass that can provision PersistentVolumes

- These PersistentVolumes will be replicated across nodes

- They should be able to withstand single-node failures

???

:EN:- Understanding Container Attached Storage (CAS)
:EN:- Deploying stateful apps with OpenEBS

:FR:- Comprendre le "Container Attached Storage" (CAS)
:FR:- Déployer une application "stateful" avec OpenEBS
.debug[[k8s/openebs.md](https://github.com/denisgaudare/container.training.git/tree/main/slides/k8s/openebs.md)]</textarea>
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        ratio: '16:9',
        highlightSpans: true,
        slideNumberFormat: '%current%/%total%',
        excludedClasses: ["self-paced"]
      });
    </script>
    
    <!-- 
    These two scripts will be available only when loading the
    content using the pub/sub server. Otherwise, they'll just
    404 and that's OK.
    -->
    <script src="/socket.io/socket.io.js">
    </script>
    <script src="/remote.js">
    </script>

  </body>
</html>
